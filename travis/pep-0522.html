<!--
This HTML is auto-generated.  DO NOT EDIT THIS FILE!  If you are writing a new
PEP, see http://www.python.org/dev/peps/pep-0001 for instructions and links
to templates.  DO NOT USE THIS HTML FILE AS YOUR TEMPLATE!
-->
<table class="rfc2822 docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">PEP:</th><td class="field-body">522</td>
</tr>
<tr class="field"><th class="field-name">Title:</th><td class="field-body">Raise BlockingIOError in security sensitive APIs on Linux</td>
</tr>
<tr class="field"><th class="field-name">Version:</th><td class="field-body">$Revision$</td>
</tr>
<tr class="field"><th class="field-name">Last-Modified:</th><td class="field-body"><a class="reference external" href="https://hg.python.org/peps/file/tip/pep-0522.txt">$Date$</a></td>
</tr>
<tr class="field"><th class="field-name">Author:</th><td class="field-body">Nick Coghlan &lt;ncoghlan&#32;&#97;t&#32;gmail.com&gt;</td>
</tr>
<tr class="field"><th class="field-name">Status:</th><td class="field-body">Draft</td>
</tr>
<tr class="field"><th class="field-name">Type:</th><td class="field-body">Standards Track</td>
</tr>
<tr class="field"><th class="field-name">Content-Type:</th><td class="field-body"><a class="reference external" href="/dev/peps/pep-0012">text/x-rst</a></td>
</tr>
<tr class="field"><th class="field-name">Created:</th><td class="field-body">16 June 2016</td>
</tr>
<tr class="field"><th class="field-name">Python-Version:</th><td class="field-body">3.6</td>
</tr>
</tbody>
</table>
<hr />
<div class="contents topic" id="contents">
<p class="topic-title first">Contents</p>
<ul class="simple">
<li><a class="reference internal" href="#abstract" id="id1">Abstract</a></li>
<li><a class="reference internal" href="#proposal" id="id2">Proposal</a></li>
<li><a class="reference internal" href="#rationale" id="id3">Rationale</a><ul>
<li><a class="reference internal" href="#why-now" id="id4">Why now?</a></li>
</ul>
</li>
<li><a class="reference internal" href="#background" id="id5">Background</a></li>
<li><a class="reference internal" href="#backwards-compatibility-impact-assessment" id="id6">Backwards Compatibility Impact Assessment</a><ul>
<li><a class="reference internal" href="#unaffected-applications" id="id7">Unaffected Applications</a></li>
<li><a class="reference internal" href="#affected-security-sensitive-applications" id="id8">Affected security sensitive applications</a></li>
<li><a class="reference internal" href="#affected-linux-specific-non-security-sensitive-applications" id="id9">Affected Linux specific non-security sensitive applications</a></li>
<li><a class="reference internal" href="#affected-portable-non-security-sensitive-applications" id="id10">Affected portable non-security sensitive applications</a></li>
</ul>
</li>
<li><a class="reference internal" href="#references" id="id11">References</a></li>
<li><a class="reference internal" href="#copyright" id="id12">Copyright</a></li>
</ul>
</div>
<div class="section" id="abstract">
<h1><a class="toc-backref" href="#id1">Abstract</a></h1>
<p>On Linux systems, the documentation for <tt class="docutils literal">os.urandom</tt> currently makes the
following contradictory promises:</p>
<ul class="simple">
<li>to provide random numbers that are suitable for security sensitive
operations (such as client authentication and cryptography)</li>
<li>to provide access to the best available randomness source provided by
the underlying operating system</li>
<li>to present a relatively thin wrapper around the system <tt class="docutils literal">/dev/urandom</tt>
device</li>
</ul>
<p>This PEP proposes that in Python 3.6+ the 3rd guarantee be dropped in order to
preserve the first two: on Linux systems that provide the <tt class="docutils literal">getrandom()</tt>
syscall, <tt class="docutils literal">os.urandom()</tt> would become a wrapper around that API, and raise
<tt class="docutils literal">BlockingIOError</tt> in cases where directly accessing <tt class="docutils literal">/dev/urandom/</tt> would
instead return random data that may not be adequately unpredictable for use in
security sensitive operations.</p>
<p>As higher level abstractions over the lower level <tt class="docutils literal">os.urandom()</tt> API, both
<tt class="docutils literal">random.SystemRandom()</tt> and the <tt class="docutils literal">secrets</tt> would also be documented as
potentially raising <tt class="docutils literal">BlockingIOError</tt>.</p>
<p>In all cases, as soon as a call to <tt class="docutils literal">os.urandom()</tt> succeeds, all future
calls to <tt class="docutils literal">os.urandom()</tt> in that process will succeed (once the operating
system random number generator is ready after system boot, it remains ready).</p>
</div>
<div class="section" id="proposal">
<h1><a class="toc-backref" href="#id2">Proposal</a></h1>
<p>This PEP proposes that in Python 3.6+, <tt class="docutils literal">os.urandom()</tt> be updated to call
the new Linux <tt class="docutils literal"><span class="pre">getrandom()`</span></tt> syscall in non-blocking mode if available and
raise <tt class="docutils literal">BlockingIOError: system random number generator is not ready</tt> if
the kernel reports that the call would block.</p>
<p>No changes are proposed for Windows or Mac OS X systems, as neither of those
platforms provides any mechanism to run Python code before the operating
system random number generator has been initialised. Mac OS X goes so far as
to kernel panic and abort the boot process if it can't properly initialise the
random number generator (although Apple's restrictions on the supported
hardware platforms make that exceedingly unlikely in practice).</p>
<p>Other *nix systems that offer a non-blocking API for requesting random numbers
suitable for use in security sensitive applications could potentially receive
a similar update, but such changes are out of scope for this particular
proposal.</p>
</div>
<div class="section" id="rationale">
<h1><a class="toc-backref" href="#id3">Rationale</a></h1>
<p>For several years now, the security community's guidance has been to use
<tt class="docutils literal">os.urandom()</tt> (or the <tt class="docutils literal">random.SystemRandom()</tt> wrapper) when implementing
security sensitive operations in Python.</p>
<p>To help improve API discoverability and make it clearer that secrecy and
simulation are not the same problem (even though they both involve
random numbers), <a class="reference external" href="/dev/peps/pep-0506">PEP 506</a> collected several of the one line recipes based
on the lower level <tt class="docutils literal">os.urandom()</tt> API into a new <tt class="docutils literal">secrets</tt> module.</p>
<p>However, this guidance has also come with a longstanding caveat: developers
writing security sensitive software at least for Linux, and potentially for
some other *BSD systems, may need to wait until the operating system's
random number generator is ready before relying on it for security sensitive
operations.</p>
<p>Unfortunately, there's currently no clear indicator to developers that their
software may not be working as expected when run early in the Linux boot
process, or on hardware without good sources of entropy to seed the operating
system's random number generator: due to the behaviour of the underlying
<tt class="docutils literal">/dev/urandom</tt> device, <tt class="docutils literal">os.urandom()</tt> on Linux returns a result either way,
and it takes extensive statistical analysis to show that a security
vulnerability exists.</p>
<p>By contrast, if <tt class="docutils literal">BlockingIOError</tt> is raised in those situations, then
developers can easily choose their desired behaviour:</p>
<ol class="arabic simple">
<li>Loop until the call succeeds (security sensitive)</li>
<li>Switch to using the random module (non-security sensitive)</li>
<li>Switch to reading <tt class="docutils literal">/dev/urandom</tt> directly (non-security sensitive)</li>
</ol>
<div class="section" id="why-now">
<h2><a class="toc-backref" href="#id4">Why now?</a></h2>
<p>The main reason is because the 3.5 SipHash initialisation bug causing a deadlock
when attempting to run Python scripts during the Linux init process resulted in
a rash of proposals to add <em>new</em> APIs like <tt class="docutils literal">getrandom()</tt>, <tt class="docutils literal">urandom_block()</tt>,
<tt class="docutils literal">pseudorandom()</tt> and <tt class="docutils literal">cryptorandom()</tt> to the <tt class="docutils literal">os</tt> module and to start
trying to educate users on when they should call those APIs instead of
<tt class="docutils literal">os.urandom()</tt>.</p>
<p>This is a <em>really</em> obscure problem, and we definitely shouldn't clutter up the
standard library with new APIs without a compelling reason, especially with the
<tt class="docutils literal">secrets</tt> module already being added as the &quot;use this and don't worry about
the low level details&quot; for developers that don't need to worry about versions
prior to Python 3.6.</p>
<p>However, it's also the case that low cost ARM devices are becoming increasingly
prevalent, with a lot of them running Linux, and a lot of folks writing
Python applications that run on those devices. That creates an opportunity to
take an obscure security problem that requires a lot of knowledge about
Linux boot processes and secure random number generation and turn it into a
relatively mundane and easy-to-find-in-an-internet-search runtime exception.</p>
</div>
</div>
<div class="section" id="background">
<h1><a class="toc-backref" href="#id5">Background</a></h1>
<p>On operating systems other than Linux, <tt class="docutils literal">os.urandom()</tt> may already block
waiting for the operating system's random number generator to be ready.</p>
<p>On Linux, even when the operating system's random number generator doesn't
consider itself ready for use in security sensitive operations, it will return
random values based on the entropy it as available.</p>
<p>This behaviour is potentially problematic, so Linux 3.17 added a new
<tt class="docutils literal">getrandom()</tt> syscall that (amongst other benefits) allows callers to
either block waiting for the random number generator to be ready, or
else request an error return if the random number generator is not ready.
Notably, the new API does <em>not</em> support the old behaviour of returning
data that is not suitable for security sensitive use cases.</p>
<p>Versions of Python prior up to and including Python 3.4 access the
Linux <tt class="docutils literal">/dev/urandom</tt> device directly.</p>
<p>Python 3.5.0 and 3.5.1 called <tt class="docutils literal">getrandom()</tt> in blocking mode in order to
avoid the use of a file descriptor to access <tt class="docutils literal">/dev/urandom</tt>. While there
were no specific problems reported due to <tt class="docutils literal">os.urandom()</tt> blocking in user
code, there <em>were</em> problems due to CPython implicitly invoking the blocking
behaviour during interpreter startup.</p>
<p>Rather than trying to decouple SipHash initialisation from the
<tt class="docutils literal">os.urandom()</tt> implementation, Python 3.5.2 switched to calling
<tt class="docutils literal">getrandom()</tt> in non-blocking mode, and falling back to reading from
<tt class="docutils literal">/dev/urandom</tt> if the syscall indicates it will block.</p>
</div>
<div class="section" id="backwards-compatibility-impact-assessment">
<h1><a class="toc-backref" href="#id6">Backwards Compatibility Impact Assessment</a></h1>
<p>Similar to <a class="reference external" href="/dev/peps/pep-0476">PEP 476</a>, this is a proposal to turn a previously silent security
failure into a noisy exception that requires the application developer to
make an explicit decision regarding the behaviour they desire.</p>
<p>As no changes are proposed for operating systems other than Linux,
<tt class="docutils literal">os.urandom()</tt> retains its existing behaviour as a nominally blocking API
that is non-blocking in practice due to the difficulty of scheduling Python
code to run before the operating system random number generator is ready. We
believe it may be possible on *BSD, but nobody has explicitly demonstrated
that. On Mac OS X and Windows, it appears to be straight up impossible to
even try to run a Python interpreter that early in the boot process.</p>
<p>On Linux, <tt class="docutils literal">os.urandom()</tt> retains its status as a guaranteed non-blocking API.
However, the means of achieving that status changes in the specific case of
the operating system random number generator not being ready for use in security
sensitive operations: historically it would return potentially predictable
random data, with this PEP it would change to raise <tt class="docutils literal">BlockingIOError</tt>.</p>
<p>Developers of affected applications would then be required to make one of the
following changes to forward compatibility with Python 3.6, based on the kind
of application they're developing.</p>
<div class="section" id="unaffected-applications">
<h2><a class="toc-backref" href="#id7">Unaffected Applications</a></h2>
<p>The following kinds of applications would be entirely unaffected by the change,
regardless of whether or not they perform security sensitive operations:</p>
<ul class="simple">
<li>applications that don't support Linux</li>
<li>applications that are only run on desktops or conventional servers</li>
<li>applications that are only run after the system RNG is ready</li>
</ul>
</div>
<div class="section" id="affected-security-sensitive-applications">
<h2><a class="toc-backref" href="#id8">Affected security sensitive applications</a></h2>
<p>Security sensitive applications would need to either change their system
configuration so the application is only started after the operating system
random number generator is ready for security sensitive operations, or else
change their code to busy loop until the operating system is ready:</p>
<pre class="literal-block">
def blocking_urandom(num_bytes):
    while True:
        try:
            return os.urandom(num_bytes)
        except BlockingIOError:
            pass
</pre>
</div>
<div class="section" id="affected-linux-specific-non-security-sensitive-applications">
<h2><a class="toc-backref" href="#id9">Affected Linux specific non-security sensitive applications</a></h2>
<p>Non-security sensitive applications that don't need to worry about cross
platform compatibility can be updated to access <tt class="docutils literal">/dev/urandom</tt> directly:</p>
<pre class="literal-block">
def dev_urandom(num_bytes):
    with open(&quot;/dev/urandom&quot;, &quot;rb&quot;) as f:
        return f.read(num_bytes)
</pre>
</div>
<div class="section" id="affected-portable-non-security-sensitive-applications">
<h2><a class="toc-backref" href="#id10">Affected portable non-security sensitive applications</a></h2>
<p>Non-security sensitive applications that don't want to assume access to
<tt class="docutils literal">/dev/urandom</tt> can be updated to use the <tt class="docutils literal">random</tt> module instead:</p>
<pre class="literal-block">
def pseudorandom(num_bytes):
    random.getrandbits(num_bytes*8).to_bytes(num_bytes, &quot;little&quot;)
</pre>
</div>
</div>
<div class="section" id="references">
<h1><a class="toc-backref" href="#id11">References</a></h1>
<ul class="simple">
<li>Victor's summary: <a class="reference external" href="http://haypo-notes.readthedocs.io/pep_random.html">http://haypo-notes.readthedocs.io/pep_random.html</a></li>
</ul>
</div>
<div class="section" id="copyright">
<h1><a class="toc-backref" href="#id12">Copyright</a></h1>
<p>This document has been placed into the public domain.</p>
<!-- Local Variables:
mode: indented-text
indent-tabs-mode: nil
sentence-end-double-space: t
fill-column: 70
coding: utf-8 -->
</div>

