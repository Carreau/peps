<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN"
                      "http://www.w3.org/TR/REC-html40/loose.dtd">
<html>
<!--
This HTML is auto-generated.  DO NOT EDIT THIS FILE!  If you are writing a new
PEP, see http://www.python.org/peps/pep-0001.html for instructions and links
to templates.  DO NOT USE THIS HTML FILE AS YOUR TEMPLATE!
-->
<head>
  <title>PEP 292 -- Simpler String Substitutions</title>
  <link rel="STYLESHEET" href="style.css" type="text/css" />
</head>
<body bgcolor="white">
<table class="navigation" cellpadding="0" cellspacing="0"
       width="100%" border="0">
<tr><td class="navicon" width="150" height="35">
<a href="../" title="Python Home Page">
<img src="../pics/PyBanner038.gif" alt="[Python]"
 border="0" width="150" height="35" /></a></td>
<td class="textlinks" align="left">
[<b><a href="../">Python Home</a></b>]
[<b><a href=".">PEP Index</a></b>]
[<b><a href="pep-0292.txt">PEP Source</a></b>]
</td></tr></table>
<div class="header">
<table border="0">
  <tr><th>PEP:&nbsp;</th><td>292</td></tr>
  <tr><th>Title:&nbsp;</th><td>Simpler String Substitutions</td></tr>
  <tr><th>Version:&nbsp;</th><td>$Revision$</td></tr>
  <tr><th>Last-Modified:&nbsp;</th><td><a href="https://hg.python.org/peps/file/tip/pep-0292.txt">$Date$</a> </td></tr>
  <tr><th>Author:&nbsp;</th><td>Barry Warsaw &lt;barry&#32;&#97;t&#32;python.org&gt;</td></tr>
  <tr><th>Status:&nbsp;</th><td>Final</td></tr>
  <tr><th>Type:&nbsp;</th><td>Standards Track</td></tr>
  <tr><th>Created:&nbsp;</th><td>18-Jun-2002</td></tr>
  <tr><th>Python-Version:&nbsp;</th><td>2.4</td></tr>
  <tr><th>Post-History:&nbsp;</th><td>18-Jun-2002, 23-Mar-2004, 22-Aug-2004</td></tr>
</table>
</div>
<hr />
<div class="content">
<h3>Abstract</h3>
<pre>
    This PEP describes a simpler string substitution feature, also
    known as string interpolation.  This PEP is &quot;simpler&quot; in two
    respects:

    1. Python&#x27;s current string substitution feature
       (i.e. %-substitution) is complicated and error prone.  This PEP
       is simpler at the cost of some expressiveness.

    2. <a href="pep-0215.html">PEP 215</a> proposed an alternative string interpolation feature,
       introducing a new `$&#x27; string prefix.  <a href="pep-0292.html">PEP 292</a> is simpler than
       this because it involves no syntax changes and has much simpler
       rules for what substitutions can occur in the string.


</pre>
<h3>Rationale</h3>
<pre>
    Python currently supports a string substitution syntax based on
    C&#x27;s printf() &#x27;%&#x27; formatting character[1].  While quite rich,
    %-formatting codes are also error prone, even for
    experienced Python programmers.  A common mistake is to leave off
    the trailing format character, e.g. the `s&#x27; in &quot;%(name)s&quot;.

    In addition, the rules for what can follow a % sign are fairly
    complex, while the usual application rarely needs such complexity.
    Most scripts need to do some string interpolation, but most of
    those use simple `stringification&#x27; formats, i.e. %s or %(name)s
    This form should be made simpler and less error prone.


</pre>
<h3>A Simpler Proposal</h3>
<pre>
    We propose the addition of a new class, called &#x27;Template&#x27;, which
    will live in the string module.  The Template class supports new
    rules for string substitution; its value contains placeholders,
    introduced with the $ character.  The following rules for
    $-placeholders apply:

    1. $$ is an escape; it is replaced with a single $

    2. $identifier names a substitution placeholder matching a mapping
       key of &quot;identifier&quot;.  By default, &quot;identifier&quot; must spell a
       Python identifier as defined in [2].  The first non-identifier
       character after the $ character terminates this placeholder
       specification.

    3. ${identifier} is equivalent to $identifier.  It is required
       when valid identifier characters follow the placeholder but are
       not part of the placeholder, e.g. &quot;${noun}ification&quot;.

    If the $ character appears at the end of the line, or is followed
    by any other character than those described above, a ValueError
    will be raised at interpolation time.  Values in mapping are
    converted automatically to strings.

    No other characters have special meaning, however it is possible
    to derive from the Template class to define different substitution
    rules.  For example, a derived class could allow for periods in
    the placeholder (e.g. to support a kind of dynamic namespace and
    attribute path lookup), or could define a delimiter character
    other than &#x27;$&#x27;.

    Once the Template has been created, substitutions can be performed
    by calling one of two methods:

    - substitute().  This method returns a new string which results
      when the values of a mapping are substituted for the
      placeholders in the Template.  If there are placeholders which
      are not present in the mapping, a KeyError will be raised.

    - safe_substitute().  This is similar to the substitute() method,
      except that KeyErrors are never raised (due to placeholders
      missing from the mapping).  When a placeholder is missing, the
      original placeholder will appear in the resulting string.

   Here are some examples:

        &gt;&gt;&gt; from string import Template
        &gt;&gt;&gt; s = Template(&#x27;${name} was born in ${country}&#x27;)
        &gt;&gt;&gt; print s.substitute(name=&#x27;Guido&#x27;, country=&#x27;the Netherlands&#x27;)
        Guido was born in the Netherlands
        &gt;&gt;&gt; print s.substitute(name=&#x27;Guido&#x27;)
        Traceback (most recent call last):
        [...]
        KeyError: &#x27;country&#x27;
        &gt;&gt;&gt; print s.safe_substitute(name=&#x27;Guido&#x27;)
        Guido was born in ${country}

    The signature of substitute() and safe_substitute() allows for
    passing the mapping of placeholders to values, either as a single
    dictionary-like object in the first positional argument, or as
    keyword arguments as shown above.  The exact details and
    signatures of these two methods is reserved for the standard
    library documentation.


</pre>
<h3>Why `$' and Braces?</h3>
<pre>
    The BDFL said it best[4]: &quot;The $ means &quot;substitution&quot; in so many
    languages besides Perl that I wonder where you&#x27;ve been. [...]
    We&#x27;re copying this from the shell.&quot;

    Thus the substitution rules are chosen because of the similarity
    with so many other languages.  This makes the substitution rules
    easier to teach, learn, and remember.


</pre>
<h3>Comparison to PEP 215</h3>
<pre>
    <a href="pep-0215.html">PEP 215</a> describes an alternate proposal for string interpolation.
    Unlike that PEP, this one does not propose any new syntax for
    Python.  All the proposed new features are embodied in a new
    library module.  <a href="pep-0215.html">PEP 215</a> proposes a new string prefix
    representation such as $&quot;&quot; which signal to Python that a new type
    of string is present.  $-strings would have to interact with the
    existing r-prefixes and u-prefixes, essentially doubling the
    number of string prefix combinations.

    <a href="pep-0215.html">PEP 215</a> also allows for arbitrary Python expressions inside the
    $-strings, so that you could do things like:

        import sys
        print $&quot;sys = $sys, sys = $sys.modules[&#x27;sys&#x27;]&quot;

    which would return

        sys = &lt;module &#x27;sys&#x27; (built-in)&gt;, sys = &lt;module &#x27;sys&#x27; (built-in)&gt;

    It&#x27;s generally accepted that the rules in <a href="pep-0215.html">PEP 215</a> are safe in the
    sense that they introduce no new security issues (see <a href="pep-0215.html">PEP 215</a>,
    &quot;Security Issues&quot; for details).  However, the rules are still
    quite complex, and make it more difficult to see the substitution
    placeholder in the original $-string.

    The interesting thing is that the Template class defined in this
    PEP is designed for inheritance and, with a little extra work,
    it&#x27;s possible to support <a href="pep-0215.html">PEP 215</a>&#x27;s functionality using existing
    Python syntax.

    For example, one could define subclasses of Template and dict that
    allowed for a more complex placeholder syntax and a mapping that
    evaluated those placeholders.


</pre>
<h3>Internationalization</h3>
<pre>
    The implementation supports internationalization by recording the
    original template string in the Template instance&#x27;s &#x27;template&#x27;
    attribute.  This attribute would serve as the lookup key in an
    gettext-based catalog.  It is up to the application to turn the
    resulting string back into a Template for substitution.

    However, the Template class was designed to work more intuitively
    in an internationalized application, by supporting the mixing-in
    of Template and unicode subclasses.  Thus an internationalized
    application could create an application-specific subclass,
    multiply inheriting from Template and unicode, and using instances
    of that subclass as the gettext catalog key.  Further, the
    subclass could alias the special __mod__() method to either
    .substitute() or .safe_substitute() to provide a more traditional
    string/unicode like %-operator substitution syntax.


</pre>
<h3>Reference Implementation</h3>
<pre>
    The implementation has been committed to the Python 2.4 source tree.


</pre>
<h3>References</h3>
<pre>
    [1] String Formatting Operations
        <a href="http://docs.python.org/library/stdtypes.html#string-formatting-operations">http://docs.python.org/library/stdtypes.html#string-formatting-operations</a>

    [2] Identifiers and Keywords
        <a href="http://docs.python.org/reference/lexical_analysis.html#identifiers-and-keywords">http://docs.python.org/reference/lexical_analysis.html#identifiers-and-keywords</a>

    [3] Guido&#x27;s python-dev posting from 21-Jul-2002
        <a href="http://mail.python.org/pipermail/python-dev/2002-July/026397.html">http://mail.python.org/pipermail/python-dev/2002-July/026397.html</a>

    [4] <a href="http://mail.python.org/pipermail/python-dev/2002-June/025652.html">http://mail.python.org/pipermail/python-dev/2002-June/025652.html</a>

    [5] Reference Implementation
        <a href="http://sourceforge.net/tracker/index.php?func=detail&amp;aid=1014055&amp;group_id=5470&amp;atid=305470">http://sourceforge.net/tracker/index.php?func=detail&amp;aid=1014055&amp;group_id=5470&amp;atid=305470</a>

</pre>
<h3>Copyright</h3>
<pre>
    This document has been placed in the public domain.



</pre>
</div>
</body>
</html>
