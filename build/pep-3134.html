<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN"
                      "http://www.w3.org/TR/REC-html40/loose.dtd">
<html>
<!--
This HTML is auto-generated.  DO NOT EDIT THIS FILE!  If you are writing a new
PEP, see http://www.python.org/peps/pep-0001.html for instructions and links
to templates.  DO NOT USE THIS HTML FILE AS YOUR TEMPLATE!
-->
<head>
  <title>PEP 3134 -- Exception Chaining and Embedded Tracebacks</title>
  <link rel="STYLESHEET" href="style.css" type="text/css" />
</head>
<body bgcolor="white">
<table class="navigation" cellpadding="0" cellspacing="0"
       width="100%" border="0">
<tr><td class="navicon" width="150" height="35">
<a href="../" title="Python Home Page">
<img src="../pics/PyBanner036.gif" alt="[Python]"
 border="0" width="150" height="35" /></a></td>
<td class="textlinks" align="left">
[<b><a href="../">Python Home</a></b>]
[<b><a href=".">PEP Index</a></b>]
[<b><a href="pep-3134.txt">PEP Source</a></b>]
</td></tr></table>
<div class="header">
<table border="0">
  <tr><th>PEP:&nbsp;</th><td>3134</td></tr>
  <tr><th>Title:&nbsp;</th><td>Exception Chaining and Embedded Tracebacks</td></tr>
  <tr><th>Version:&nbsp;</th><td>$Revision$</td></tr>
  <tr><th>Last-Modified:&nbsp;</th><td><a href="https://hg.python.org/peps/file/tip/pep-3134.txt">$Date$</a> </td></tr>
  <tr><th>Author:&nbsp;</th><td>Ka-Ping Yee</td></tr>
  <tr><th>Status:&nbsp;</th><td>Final</td></tr>
  <tr><th>Type:&nbsp;</th><td>Standards Track</td></tr>
  <tr><th>Content-Type:&nbsp;</th><td><a href="pep-0009.html">text/plain</a> </td></tr>
  <tr><th>Created:&nbsp;</th><td>12-May-2005</td></tr>
  <tr><th>Python-Version:&nbsp;</th><td>3.0</td></tr>
  <tr><th>Post-History:&nbsp;</th><td></td></tr>
</table>
</div>
<hr />
<div class="content">
<h3>Numbering Note</h3>
<pre>
    This PEP started its life as <a href="pep-0344.html">PEP 344</a>.  Since it is now targeted
    for Python 3000, it has been moved into the 3xxx space.


</pre>
<h3>Abstract</h3>
<pre>
    This PEP proposes three standard attributes on exception instances:
    the &#x27;__context__&#x27; attribute for implicitly chained exceptions, the
    &#x27;__cause__&#x27; attribute for explicitly chained exceptions, and the
    &#x27;__traceback__&#x27; attribute for the traceback.  A new &quot;raise ... from&quot;
    statement sets the &#x27;__cause__&#x27; attribute.


</pre>
<h3>Motivation</h3>
<pre>
    During the handling of one exception (exception A), it is possible
    that another exception (exception B) may occur.  In today&#x27;s Python
    (version 2.4), if this happens, exception B is propagated outward
    and exception A is lost.  In order to debug the problem, it is
    useful to know about both exceptions.  The &#x27;__context__&#x27; attribute
    retains this information automatically.

    Sometimes it can be useful for an exception handler to intentionally
    re-raise an exception, either to provide extra information or to
    translate an exception to another type.  The &#x27;__cause__&#x27; attribute
    provides an explicit way to record the direct cause of an exception.

    In today&#x27;s Python implementation, exceptions are composed of three
    parts: the type, the value, and the traceback.  The &#x27;sys&#x27; module,
    exposes the current exception in three parallel variables, exc_type,
    exc_value, and exc_traceback, the sys.exc_info() function returns a
    tuple of these three parts, and the &#x27;raise&#x27; statement has a
    three-argument form accepting these three parts.  Manipulating
    exceptions often requires passing these three things in parallel,
    which can be tedious and error-prone.  Additionally, the &#x27;except&#x27;
    statement can only provide access to the value, not the traceback.
    Adding the &#x27;__traceback__&#x27; attribute to exception values makes all
    the exception information accessible from a single place.


</pre>
<h3>History</h3>
<pre>
    Raymond Hettinger [1] raised the issue of masked exceptions on
    Python-Dev in January 2003 and proposed a PyErr_FormatAppend()
    function that C modules could use to augment the currently active
    exception with more information.  Brett Cannon [2] brought up
    chained exceptions again in June 2003, prompting a long discussion.

    Greg Ewing [3] identified the case of an exception occuring in a
    &#x27;finally&#x27; block during unwinding triggered by an original exception,
    as distinct from the case of an exception occuring in an &#x27;except&#x27;
    block that is handling the original exception.

    Greg Ewing [4] and Guido van Rossum [5], and probably others, have
    previously mentioned adding a traceback attribute to Exception
    instances.  This is noted in <a href="pep-3000.html">PEP 3000</a>.

    This PEP was motivated by yet another recent Python-Dev reposting
    of the same ideas [6] [7].


</pre>
<h3>Rationale</h3>
<pre>
    The Python-Dev discussions revealed interest in exception chaining
    for two quite different purposes.  To handle the unexpected raising
    of a secondary exception, the exception must be retained implicitly.
    To support intentional translation of an exception, there must be a
    way to chain exceptions explicitly.  This PEP addresses both.

    Several attribute names for chained exceptions have been suggested
    on Python-Dev [2], including &#x27;cause&#x27;, &#x27;antecedent&#x27;, &#x27;reason&#x27;,
    &#x27;original&#x27;, &#x27;chain&#x27;, &#x27;chainedexc&#x27;, &#x27;exc_chain&#x27;, &#x27;excprev&#x27;,
    &#x27;previous&#x27;, and &#x27;precursor&#x27;.  For an explicitly chained exception,
    this PEP suggests &#x27;__cause__&#x27; because of its specific meaning.  For
    an implicitly chained exception, this PEP proposes the name
    &#x27;__context__&#x27; because the intended meaning is more specific than
    temporal precedence but less specific than causation: an exception
    occurs in the context of handling another exception.
    
    This PEP suggests names with leading and trailing double-underscores
    for these three attributes because they are set by the Python VM.
    Only in very special cases should they be set by normal assignment.

    This PEP handles exceptions that occur during &#x27;except&#x27; blocks and
    &#x27;finally&#x27; blocks in the same way.  Reading the traceback makes it
    clear where the exceptions occurred, so additional mechanisms for
    distinguishing the two cases would only add unnecessary complexity.

    This PEP proposes that the outermost exception object (the one
    exposed for matching by &#x27;except&#x27; clauses) be the most recently
    raised exception for compatibility with current behaviour.

    This PEP proposes that tracebacks display the outermost exception
    last, because this would be consistent with the chronological order
    of tracebacks (from oldest to most recent frame) and because the
    actual thrown exception is easier to find on the last line.

    To keep things simpler, the C API calls for setting an exception
    will not automatically set the exception&#x27;s &#x27;__context__&#x27;.  Guido
    van Rossum has expressed concerns with making such changes [8].

    As for other languages, Java and Ruby both discard the original
    exception when another exception occurs in a &#x27;catch&#x27;/&#x27;rescue&#x27; or
    &#x27;finally&#x27;/&#x27;ensure&#x27; clause.  Perl 5 lacks built-in structured
    exception handling.  For Perl 6, RFC number 88 [9] proposes an exception
    mechanism that implicitly retains chained exceptions in an array
    named @@.  In that RFC, the most recently raised exception is
    exposed for matching, as in this PEP; also, arbitrary expressions
    (possibly involving @@) can be evaluated for exception matching.

    Exceptions in C# contain a read-only &#x27;InnerException&#x27; property that
    may point to another exception.  Its documentation [10] says that
    &quot;When an exception X is thrown as a direct result of a previous
    exception Y, the InnerException property of X should contain a
    reference to Y.&quot;  This property is not set by the VM automatically;
    rather, all exception constructors take an optional &#x27;innerException&#x27;
    argument to set it explicitly.  The &#x27;__cause__&#x27; attribute fulfills
    the same purpose as InnerException, but this PEP proposes a new form
    of &#x27;raise&#x27; rather than extending the constructors of all exceptions.
    C# also provides a GetBaseException method that jumps directly to
    the end of the InnerException chain; this PEP proposes no analog.

    The reason all three of these attributes are presented together in
    one proposal is that the &#x27;__traceback__&#x27; attribute provides
    convenient access to the traceback on chained exceptions.


</pre>
<h3>Implicit Exception Chaining</h3>
<pre>
    Here is an example to illustrate the &#x27;__context__&#x27; attribute.

        def compute(a, b):
            try:
                a/b
            except Exception, exc:
                log(exc)

        def log(exc):
            file = open(&#x27;logfile.txt&#x27;)  # oops, forgot the &#x27;w&#x27;
            print &gt;&gt;file, exc
            file.close()

    Calling compute(0, 0) causes a ZeroDivisionError.  The compute()
    function catches this exception and calls log(exc), but the log()
    function also raises an exception when it tries to write to a
    file that wasn&#x27;t opened for writing.

    In today&#x27;s Python, the caller of compute() gets thrown an IOError.
    The ZeroDivisionError is lost.  With the proposed change, the
    instance of IOError has an additional &#x27;__context__&#x27; attribute that
    retains the ZeroDivisionError.

    The following more elaborate example demonstrates the handling of a
    mixture of &#x27;finally&#x27; and &#x27;except&#x27; clauses:

        def main(filename):
            file = open(filename)       # oops, forgot the &#x27;w&#x27;
            try:
                try:
                    compute()
                except Exception, exc:
                    log(file, exc)
            finally:
                file.clos()             # oops, misspelled &#x27;close&#x27;
        
        def compute():
            1/0
        
        def log(file, exc):
            try:
                print &gt;&gt;file, exc       # oops, file is not writable
            except:
                display(exc)
        
        def display(exc):
            print ex                    # oops, misspelled &#x27;exc&#x27;

    Calling main() with the name of an existing file will trigger four
    exceptions.  The ultimate result will be an AttributeError due to
    the misspelling of &#x27;clos&#x27;, whose __context__ points to a NameError
    due to the misspelling of &#x27;ex&#x27;, whose __context__ points to an
    IOError due to the file being read-only, whose __context__ points to
    a ZeroDivisionError, whose __context__ attribute is None.

    The proposed semantics are as follows:

    1.  Each thread has an exception context initially set to None.
    
    2.  Whenever an exception is raised, if the exception instance does
        not already have a &#x27;__context__&#x27; attribute, the interpreter sets
        it equal to the thread&#x27;s exception context.

    3.  Immediately after an exception is raised, the thread&#x27;s exception
        context is set to the exception.

    4.  Whenever the interpreter exits an &#x27;except&#x27; block by reaching the
        end or executing a &#x27;return&#x27;, &#x27;yield&#x27;, &#x27;continue&#x27;, or &#x27;break&#x27;
        statement, the thread&#x27;s exception context is set to None.


</pre>
<h3>Explicit Exception Chaining</h3>
<pre>
    The &#x27;__cause__&#x27; attribute on exception objects is always initialized
    to None.  It is set by a new form of the &#x27;raise&#x27; statement:

        raise EXCEPTION from CAUSE

    which is equivalent to:

        exc = EXCEPTION
        exc.__cause__ = CAUSE
        raise exc
    
    In the following example, a database provides implementations for a
    few different kinds of storage, with file storage as one kind.  The
    database designer wants errors to propagate as DatabaseError objects
    so that the client doesn&#x27;t have to be aware of the storage-specific
    details, but doesn&#x27;t want to lose the underlying error information.

        class DatabaseError(Exception):
            pass

        class FileDatabase(Database):
            def __init__(self, filename):
                try:
                    self.file = open(filename)
                except IOError, exc:
                    raise DatabaseError(&#x27;failed to open&#x27;) from exc

    If the call to open() raises an exception, the problem will be
    reported as a DatabaseError, with a __cause__ attribute that reveals
    the IOError as the original cause.


</pre>
<h3>Traceback Attribute</h3>
<pre>
    The following example illustrates the &#x27;__traceback__&#x27; attribute.

        def do_logged(file, work):
            try:
                work()
            except Exception, exc:
                write_exception(file, exc)
                raise exc

        from traceback import format_tb

        def write_exception(file, exc):
            ...
            type = exc.__class__
            message = str(exc)
            lines = format_tb(exc.__traceback__)
            file.write(... type ... message ... lines ...)
            ...

    In today&#x27;s Python, the do_logged() function would have to extract
    the traceback from sys.exc_traceback or sys.exc_info()[2] and pass
    both the value and the traceback to write_exception().  With the
    proposed change, write_exception() simply gets one argument and
    obtains the exception using the &#x27;__traceback__&#x27; attribute.

    The proposed semantics are as follows:

    1.  Whenever an exception is caught, if the exception instance does
        not already have a &#x27;__traceback__&#x27; attribute, the interpreter
        sets it to the newly caught traceback.


</pre>
<h3>Enhanced Reporting</h3>
<pre>
    The default exception handler will be modified to report chained
    exceptions.  The chain of exceptions is traversed by following the
    &#x27;__cause__&#x27; and &#x27;__context__&#x27; attributes, with &#x27;__cause__&#x27; taking
    priority.  In keeping with the chronological order of tracebacks,
    the most recently raised exception is displayed last; that is, the
    display begins with the description of the innermost exception and
    backs up the chain to the outermost exception.  The tracebacks are
    formatted as usual, with one of the lines:

        The above exception was the direct cause of the following exception:

    or

        During handling of the above exception, another exception occurred:

    between tracebacks, depending whether they are linked by __cause__
    or __context__ respectively.  Here is a sketch of the procedure:
    
        def print_chain(exc):
            if exc.__cause__:
                print_chain(exc.__cause__)
                print &#x27;\nThe above exception was the direct cause...&#x27;
            elif exc.__context__:
                print_chain(exc.__context__)
                print &#x27;\nDuring handling of the above exception, ...&#x27;
            print_exc(exc)

    In the &#x27;traceback&#x27; module, the format_exception, print_exception,
    print_exc, and print_last functions will be updated to accept an
    optional &#x27;chain&#x27; argument, True by default.  When this argument is
    True, these functions will format or display the entire chain of
    exceptions as just described.  When it is False, these functions
    will format or display only the outermost exception.

    The &#x27;cgitb&#x27; module should also be updated to display the entire
    chain of exceptions.


</pre>
<h3>C API</h3>
<pre>
    The PyErr_Set* calls for setting exceptions will not set the
    &#x27;__context__&#x27; attribute on exceptions.  PyErr_NormalizeException
    will always set the &#x27;traceback&#x27; attribute to its &#x27;tb&#x27; argument and
    the &#x27;__context__&#x27; and &#x27;__cause__&#x27; attributes to None.

    A new API function, PyErr_SetContext(context), will help C
    programmers provide chained exception information.  This function
    will first normalize the current exception so it is an instance,
    then set its &#x27;__context__&#x27; attribute.  A similar API function,
    PyErr_SetCause(cause), will set the &#x27;__cause__&#x27; attribute.


</pre>
<h3>Compatibility</h3>
<pre>
    Chained exceptions expose the type of the most recent exception, so
    they will still match the same &#x27;except&#x27; clauses as they do now.

    The proposed changes should not break any code unless it sets or
    uses attributes named &#x27;__context__&#x27;, &#x27;__cause__&#x27;, or &#x27;__traceback__&#x27;
    on exception instances.  As of 2005-05-12, the Python standard
    library contains no mention of such attributes.


</pre>
<h3>Open Issue:  Extra Information</h3>
<pre>
    Walter Dörwald [11] expressed a desire to attach extra information
    to an exception during its upward propagation without changing its
    type.  This could be a useful feature, but it is not addressed by
    this PEP.  It could conceivably be addressed by a separate PEP
    establishing conventions for other informational attributes on
    exceptions.


</pre>
<h3>Open Issue:  Suppressing Context</h3>
<pre>
    As written, this PEP makes it impossible to suppress &#x27;__context__&#x27;,
    since setting exc.__context__ to None in an &#x27;except&#x27; or &#x27;finally&#x27;
    clause will only result in it being set again when exc is raised.


</pre>
<h3>Open Issue:  Limiting Exception Types</h3>
<pre>
    To improve encapsulation, library implementors may want to wrap all
    implementation-level exceptions with an application-level exception.
    One could try to wrap exceptions by writing this:

        try:
            ... implementation may raise an exception ...
        except:
            import sys
            raise ApplicationError from sys.exc_value

    or this:

        try:
            ... implementation may raise an exception ...
        except Exception, exc:
            raise ApplicationError from exc

    but both are somewhat flawed.  It would be nice to be able to name
    the current exception in a catch-all &#x27;except&#x27; clause, but that isn&#x27;t
    addressed here.  Such a feature would allow something like this:

        try:
            ... implementation may raise an exception ...
        except *, exc:
            raise ApplicationError from exc


</pre>
<h3>Open Issue:  yield</h3>
<pre>
    The exception context is lost when a &#x27;yield&#x27; statement is executed;
    resuming the frame after the &#x27;yield&#x27; does not restore the context.
    Addressing this problem is out of the scope of this PEP; it is not a
    new problem, as demonstrated by the following example:

        &gt;&gt;&gt; def gen():
        ...     try:
        ...         1/0
        ...     except:
        ...         yield 3
        ...         raise
        ...
        &gt;&gt;&gt; g = gen()
        &gt;&gt;&gt; g.next()
        3
        &gt;&gt;&gt; g.next()
        TypeError: exceptions must be classes, instances, or strings
        (deprecated), not NoneType


</pre>
<h3>Open Issue:  Garbage Collection</h3>
<pre>
    The strongest objection to this proposal has been that it creates
    cycles between exceptions and stack frames [12].  Collection of
    cyclic garbage (and therefore resource release) can be greatly
    delayed.

        &gt;&gt;&gt; try:
        &gt;&gt;&gt;   1/0
        &gt;&gt;&gt; except Exception, err:
        &gt;&gt;&gt;   pass

    will introduce a cycle from err -&gt; traceback -&gt; stack frame -&gt; err,
    keeping all locals in the same scope alive until the next GC happens.

    Today, these locals would go out of scope.  There is lots of code
    which assumes that &quot;local&quot; resources -- particularly open files -- will
    be closed quickly.  If closure has to wait for the next GC, a program
    (which runs fine today) may run out of file handles.

    Making the __traceback__ attribute a weak reference would avoid the
    problems with cyclic garbage.  Unfortunately, it would make saving
    the Exception for later (as unittest does) more awkward, and it would
    not allow as much cleanup of the sys module.

    A possible alternate solution, suggested by Adam Olsen, would be to
    instead turn the reference from the stack frame to the &#x27;err&#x27; variable
    into a weak reference when the variable goes out of scope [13].

  
</pre>
<h3>Possible Future Compatible Changes</h3>
<pre>
    These changes are consistent with the appearance of exceptions as
    a single object rather than a triple at the interpreter level.

    - If <a href="pep-0340.html">PEP 340</a> or <a href="pep-0343.html">PEP 343</a> is accepted, replace the three (type, value,
      traceback) arguments to __exit__ with a single exception argument.

    - Deprecate sys.exc_type, sys.exc_value, sys.exc_traceback, and
      sys.exc_info() in favour of a single member, sys.exception.

    - Deprecate sys.last_type, sys.last_value, and sys.last_traceback
      in favour of a single member, sys.last_exception.

    - Deprecate the three-argument form of the &#x27;raise&#x27; statement in
      favour of the one-argument form.

    - Upgrade cgitb.html() to accept a single value as its first
      argument as an alternative to a (type, value, traceback) tuple.


</pre>
<h3>Possible Future Incompatible Changes</h3>
<pre>
    These changes might be worth considering for Python 3000.

    - Remove sys.exc_type, sys.exc_value, sys.exc_traceback, and
      sys.exc_info().

    - Remove sys.last_type, sys.last_value, and sys.last_traceback.

    - Replace the three-argument sys.excepthook with a one-argument
      API, and changing the &#x27;cgitb&#x27; module to match.

    - Remove the three-argument form of the &#x27;raise&#x27; statement.

    - Upgrade traceback.print_exception to accept an &#x27;exception&#x27;
      argument instead of the type, value, and traceback arguments.


</pre>
<h3>Implementation</h3>
<pre>
    The __traceback__ and __cause__ attributes and the new raise syntax were
    implemented in revision 57783 [14].


</pre>
<h3>Acknowledgements</h3>
<pre>
    Brett Cannon, Greg Ewing, Guido van Rossum, Jeremy Hylton, Phillip
    J. Eby, Raymond Hettinger, Walter Dörwald, and others.


</pre>
<h3>References</h3>
<pre>
    [1] Raymond Hettinger, &quot;Idea for avoiding exception masking&quot;
        <a href="http://mail.python.org/pipermail/python-dev/2003-January/032492.html">http://mail.python.org/pipermail/python-dev/2003-January/032492.html</a>

    [2] Brett Cannon explains chained exceptions
        <a href="http://mail.python.org/pipermail/python-dev/2003-June/036063.html">http://mail.python.org/pipermail/python-dev/2003-June/036063.html</a>

    [3] Greg Ewing points out masking caused by exceptions during finally
        <a href="http://mail.python.org/pipermail/python-dev/2003-June/036290.html">http://mail.python.org/pipermail/python-dev/2003-June/036290.html</a>

    [4] Greg Ewing suggests storing the traceback in the exception object
        <a href="http://mail.python.org/pipermail/python-dev/2003-June/036092.html">http://mail.python.org/pipermail/python-dev/2003-June/036092.html</a>

    [5] Guido van Rossum mentions exceptions having a traceback attribute
        <a href="http://mail.python.org/pipermail/python-dev/2005-April/053060.html">http://mail.python.org/pipermail/python-dev/2005-April/053060.html</a>

    [6] Ka-Ping Yee, &quot;Tidier Exceptions&quot;
        <a href="http://mail.python.org/pipermail/python-dev/2005-May/053671.html">http://mail.python.org/pipermail/python-dev/2005-May/053671.html</a>

    [7] Ka-Ping Yee, &quot;Chained Exceptions&quot;
        <a href="http://mail.python.org/pipermail/python-dev/2005-May/053672.html">http://mail.python.org/pipermail/python-dev/2005-May/053672.html</a>

    [8] Guido van Rossum discusses automatic chaining in PyErr_Set*
        <a href="http://mail.python.org/pipermail/python-dev/2003-June/036180.html">http://mail.python.org/pipermail/python-dev/2003-June/036180.html</a>

    [9] Tony Olensky, &quot;Omnibus Structured Exception/Error Handling Mechanism&quot;
        <a href="http://dev.perl.org/perl6/rfc/88.html">http://dev.perl.org/perl6/rfc/88.html</a>
     
   [10] MSDN .NET Framework Library, &quot;Exception.InnerException Property&quot;
        <a href="http://msdn.microsoft.com/library/en-us/cpref/html/frlrfsystemexceptionclassinnerexceptiontopic.asp">http://msdn.microsoft.com/library/en-us/cpref/html/frlrfsystemexceptionclassinnerexceptiontopic.asp</a>

   [11] Walter Dörwald suggests wrapping exceptions to add details
        <a href="http://mail.python.org/pipermail/python-dev/2003-June/036148.html">http://mail.python.org/pipermail/python-dev/2003-June/036148.html</a>

   [12] Guido van Rossum restates the objection to cyclic trash
        <a href="http://mail.python.org/pipermail/python-3000/2007-January/005322.html">http://mail.python.org/pipermail/python-3000/2007-January/005322.html</a>

   [13] Adam Olsen suggests using a weakref from stack frame to exception
        <a href="http://mail.python.org/pipermail/python-3000/2007-January/005363.html">http://mail.python.org/pipermail/python-3000/2007-January/005363.html</a>

   [14] Patch to implement the bulk of the PEP
        <a href="http://svn.python.org/view/python/branches/py3k/Include/?rev=57783&amp;view=rev">http://svn.python.org/view/python/branches/py3k/Include/?rev=57783&amp;view=rev</a>


</pre>
<h3>Copyright</h3>
<pre>
    This document has been placed in the public domain.


</pre>
</div>
</body>
</html>
