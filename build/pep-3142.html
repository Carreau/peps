<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN"
                      "http://www.w3.org/TR/REC-html40/loose.dtd">
<html>
<!--
This HTML is auto-generated.  DO NOT EDIT THIS FILE!  If you are writing a new
PEP, see http://www.python.org/peps/pep-0001.html for instructions and links
to templates.  DO NOT USE THIS HTML FILE AS YOUR TEMPLATE!
-->
<head>
  <title>PEP 3142 -- Add a &quot;while&quot; clause to generator expressions</title>
  <link rel="STYLESHEET" href="style.css" type="text/css" />
</head>
<body bgcolor="white">
<table class="navigation" cellpadding="0" cellspacing="0"
       width="100%" border="0">
<tr><td class="navicon" width="150" height="35">
<a href="../" title="Python Home Page">
<img src="../pics/PyBanner039.gif" alt="[Python]"
 border="0" width="150" height="35" /></a></td>
<td class="textlinks" align="left">
[<b><a href="../">Python Home</a></b>]
[<b><a href=".">PEP Index</a></b>]
[<b><a href="pep-3142.txt">PEP Source</a></b>]
</td></tr></table>
<div class="header">
<table border="0">
  <tr><th>PEP:&nbsp;</th><td>3142</td></tr>
  <tr><th>Title:&nbsp;</th><td>Add a &quot;while&quot; clause to generator expressions</td></tr>
  <tr><th>Version:&nbsp;</th><td>$Revision$</td></tr>
  <tr><th>Last-Modified:&nbsp;</th><td><a href="https://hg.python.org/peps/file/tip/pep-3142.txt">$Date$</a> </td></tr>
  <tr><th>Author:&nbsp;</th><td>Gerald Britton &lt;gerald.britton&#32;&#97;t&#32;gmail.com&gt;</td></tr>
  <tr><th>Status:&nbsp;</th><td>Rejected</td></tr>
  <tr><th>Type:&nbsp;</th><td>Standards Track</td></tr>
  <tr><th>Content-Type:&nbsp;</th><td><a href="pep-0009.html">text/plain</a> </td></tr>
  <tr><th>Created:&nbsp;</th><td>12-Jan-2009</td></tr>
  <tr><th>Python-Version:&nbsp;</th><td>3.0</td></tr>
  <tr><th>Post-History:&nbsp;</th><td></td></tr>
  <tr><th>Resolution:&nbsp;</th><td>http://mail.python.org/pipermail/python-dev/2013-May/126136.html</td></tr>
</table>
</div>
<hr />
<div class="content">
<h3>Abstract</h3>
<pre>
   This PEP proposes an enhancement to generator expressions, adding a
   &quot;while&quot; clause to complement the existing &quot;if&quot; clause.


</pre>
<h3>Rationale</h3>
<pre>
   A generator expression (<a href="pep-0289.html">PEP 289</a> [1]) is a concise method to serve
   dynamically-generated objects to list comprehensions (<a href="pep-0202.html">PEP 202</a> [2]).
   Current generator expressions allow for an &quot;if&quot; clause to filter
   the objects that are returned to those meeting some set of
   criteria.  However, since the &quot;if&quot; clause is evaluated for every
   object that may be returned, in some cases it is possible that all
   objects would be rejected after a certain point.  For example:

       g = (n for n in range(100) if n*n &lt; 50)

   which is equivalent to the using a generator function
   (<a href="pep-0255.html">PEP 255</a> [3]):

       def __gen(exp):
           for n in exp:
               if n*n &lt; 50:
                   yield n
       g = __gen(iter(range(10)))

   would yield 0, 1, 2, 3, 4, 5, 6 and 7, but would also consider
   the numbers from 8 to 99 and reject them all since n*n &gt;= 50 for
   numbers in that range.  Allowing for a &quot;while&quot; clause would allow
   the redundant tests to be short-circuited:

       g = (n for n in range(100) while n*n &lt; 50)

   would also yield 0, 1, 2, 3, 4, 5, 6 and 7, but would stop at 8
   since the condition (n*n &lt; 50) is no longer true.  This would be
   equivalent to the generator function:

       def __gen(exp):
           for n in exp:
               if n*n &lt; 50:
                   yield n
               else:
                   break
       g = __gen(iter(range(100)))

   Currently, in order to achieve the same result, one would need to
   either write a generator function such as the one above or use the
   takewhile function from itertools:

       from itertools import takewhile
       g = takewhile(lambda n: n*n &lt; 50, range(100))

   The takewhile code achieves the same result as the proposed syntax,
   albeit in a longer (some would say &quot;less-elegant&quot;) fashion.  Also,
   the takewhile version requires an extra function call (the lambda
   in the example above) with the associated performance penalty.
   A simple test shows that:

       for n in (n for n in range(100) if 1): pass

   performs about 10% better than:

       for n in takewhile(lambda n: 1, range(100)): pass

   though they achieve similar results.  (The first example uses a
   generator; takewhile is an iterator).  If similarly implemented,
   a &quot;while&quot; clause should perform about the same as the &quot;if&quot; clause
   does today.

   The reader may ask if the &quot;if&quot; and &quot;while&quot; clauses should be
   mutually exclusive.  There are good examples that show that there
   are times when both may be used to good advantage. For example:

       p = (p for p in primes() if p &gt; 100 while p &lt; 1000)

   should return prime numbers found between 100 and 1000, assuming
   I have a primes() generator that yields prime numbers.

   Adding a &quot;while&quot; clause to generator expressions maintains the
   compact form while adding a useful facility for short-circuiting
   the expression.


</pre>
<h3>Acknowledgements</h3>
<pre>
   Raymond Hettinger first proposed the concept of generator
   expressions in January 2002.


</pre>
<h3>References</h3>
<pre>
   [1] <a href="pep-0289.html">PEP 289</a>: Generator Expressions
       <a href="http://www.python.org/dev/peps/pep-0289/">http://www.python.org/dev/peps/pep-0289/</a>

   [2] <a href="pep-0202.html">PEP 202</a>: List Comprehensions
       <a href="http://www.python.org/dev/peps/pep-0202/">http://www.python.org/dev/peps/pep-0202/</a>

   [3] <a href="pep-0255.html">PEP 255</a>: Simple Generators
       <a href="http://www.python.org/dev/peps/pep-0255/">http://www.python.org/dev/peps/pep-0255/</a>


</pre>
<h3>Copyright</h3>
<pre>
   This document has been placed in the public domain.


</pre>
</div>
</body>
</html>
