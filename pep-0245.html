<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN"
                      "http://www.w3.org/TR/REC-html40/loose.dtd">
<html>
<!--
This HTML is auto-generated.  DO NOT EDIT THIS FILE!  If you are writing a new
PEP, see http://www.python.org/peps/pep-0001.html for instructions and links
to templates.  DO NOT USE THIS HTML FILE AS YOUR TEMPLATE!
-->
<head>
  <title>PEP 245 -- Python Interface Syntax</title>
  <link rel="STYLESHEET" href="style.css" type="text/css" />
</head>
<body bgcolor="white">
<table class="navigation" cellpadding="0" cellspacing="0"
       width="100%" border="0">
<tr><td class="navicon" width="150" height="35">
<a href="../" title="Python Home Page">
<img src="../pics/PyBanner061.gif" alt="[Python]"
 border="0" width="150" height="35" /></a></td>
<td class="textlinks" align="left">
[<b><a href="../">Python Home</a></b>]
[<b><a href=".">PEP Index</a></b>]
[<b><a href="pep-0245.txt">PEP Source</a></b>]
</td></tr></table>
<div class="header">
<table border="0">
  <tr><th>PEP:&nbsp;</th><td>245</td></tr>
  <tr><th>Title:&nbsp;</th><td>Python Interface Syntax</td></tr>
  <tr><th>Version:&nbsp;</th><td>$Revision$</td></tr>
  <tr><th>Last-Modified:&nbsp;</th><td><a href="https://hg.python.org/peps/file/tip/pep-0245.txt">$Date$</a> </td></tr>
  <tr><th>Author:&nbsp;</th><td>Michel Pelletier &lt;michel&#32;&#97;t&#32;users.sourceforge.net&gt;</td></tr>
  <tr><th>Discussions-To:&nbsp;</th><td><a href="http://www.zope.org/Wikis/Interfaces">http://www.zope.org/Wikis/Interfaces</a></td></tr>
  <tr><th>Status:&nbsp;</th><td>Rejected</td></tr>
  <tr><th>Type:&nbsp;</th><td>Standards Track</td></tr>
  <tr><th>Created:&nbsp;</th><td>11-Jan-2001</td></tr>
  <tr><th>Python-Version:&nbsp;</th><td>2.2</td></tr>
  <tr><th>Post-History:&nbsp;</th><td>21-Mar-2001</td></tr>
</table>
</div>
<hr />
<div class="content">
<h3>Rejection Notice</h3>
<pre>
    I&#x27;m rejecting this PEP.  It&#x27;s been five years now.  While at some
    point I expect that Python will have interfaces, it would be naive
    to expect it to resemble the syntax in this PEP.  Also, <a href="pep-0246.html">PEP 246</a> is
    being rejected in favor of something completely different; interfaces
    won&#x27;t play a role in adaptation or whatever will replace it.  GvR.


</pre>
<h3>Introduction</h3>
<pre>
    This PEP describes a proposed syntax for creating interface
    objects in Python.


</pre>
<h3>Overview</h3>
<pre>
    In addition to thinking about adding a static type system to
    Python, the Types-SIG was also charged to devise an interface
    system for Python.  In December of 1998, Jim Fulton released a
    prototype interfaces system based on discussions from the SIG.
    Many of the issues and background information on this discussion
    and prototype can be found in the SIG archives[1].

    Around the end of 2000, Digital Creations began thinking about
    better component model designs for Zope[2].  Zope&#x27;s future
    component model relies heavily on interface objects.  This led to
    further development of Jim&#x27;s &quot;Scarecrow&quot; interfaces prototype.
    Starting with version 2.3, Zope comes with an Interface package as
    standard software.  Zope&#x27;s Interface package is used as the
    reference implementation for this PEP.

    The syntax proposed by this PEP relies on syntax enhancements
    describe in <a href="pep-0232.html">PEP 232</a> [3] and describes an underlying framework
    which <a href="pep-0233.html">PEP 233</a> [4] could be based upon.  There is some work being
    done with regard to interface objects and Proxy objects, so for
    those optional parts of this PEP you may want to see[5].


</pre>
<h3>The Problem</h3>
<pre>
    Interfaces are important because they solve a number of problems
    that arise while developing software:

    - There are many implied interfaces in Python, commonly referred
      to as &quot;protocols&quot;.  Currently determining those protocols is
      based on implementation introspection, but often that also
      fails.  For example, defining __getitem__ implies both a
      sequence and a mapping (the former with sequential, integer
      keys).  There is no way for the developer to be explict about
      which protocols the object intends to implement.

    - Python is limited, from the developer&#x27;s point of view, by the
      split between types and classes.  When types are expected, the
      consumer uses code like &#x27;type(foo) == type(&quot;&quot;)&#x27; to determine if
      &#x27;foo&#x27; is a string.  When instances of classes are expected, the
      consumer uses &#x27;isinstance(foo, MyString)&#x27; to determine if &#x27;foo&#x27;
      is an instance of the &#x27;MyString&#x27; class.  There is no unified
      model for determining if an object can be used in a certain,
      valid way.

    - Python&#x27;s dynamic typing is very flexible and powerful, but it
      does not have the advantage of static typed languages that
      provide type checking.  Static typed langauges provide you with
      much more type saftey, but are often overly verbose because
      objects can only be generalized by common subclassing and used
      specificly with casting (for example, in Java).

    There are also a number of documentation problems that interfaces
    try to solve.

    - Developers waste a lot of time looking at the source code of
      your system to figure out how objects work.

    - Developers who are new to your system may misunderstand how your
      objects work, causing, and possibly propagating, usage errors.

    - Because a lack of interfaces means usage is inferred from the
      source, developers may end up using methods and attributes that
      are meant for &quot;internal use only&quot;.

    - Code inspection can be hard, and very discouraging to novice
      programmers trying to properly understand code written by gurus.

    - A lot of time is wasted when many people try very hard to
      understand obscurity (like undocumented software).  Effort spend
      up front documenting interfaces will save much of this time in
      the end.

    Interfaces try to solve these problems by providing a way for you
    to specify a contractual obligation for your object, documentation
    on how to use an object, and a built-in mechanism for discovering
    the contract and the documentation.

    Python has very useful introspection features.  It is well known
    that this makes exploring concepts in the interactive interpreter
    easier, because Python gives you the ability to look at all kinds
    of information about the objects: the type, doc strings, instance
    dictionaries, base classes, unbound methods and more.

    Many of these features are oriented toward introspecting, using
    and changing the implementation of software, and one of them (&quot;doc
    strings&quot;) is oriented toward providing documentation.  This
    proposal describes an extension to this natural introspection
    framework that describes an object&#x27;s interface.


</pre>
<h3>Overview of the Interface Syntax</h3>
<pre>
    For the most part, the syntax of interfaces is very much like the
    syntax of classes, but future needs, or needs brought up in
    discussion, may define new possibilities for interface syntax.

    A formal BNF description of the syntax is givena later in the PEP,
    for the purposes of illustration, here is an example of two
    different interfaces created with the proposed syntax:

        interface CountFishInterface:
            &quot;Fish counting interface&quot;

            def oneFish():
                &quot;Increments the fish count by one&quot;

            def twoFish():
                &quot;Increments the fish count by two&quot;

            def getFishCount():
                &quot;Returns the fish count&quot;

        interface ColorFishInterface:
            &quot;Fish coloring interface&quot;

            def redFish():
                &quot;Sets the current fish color to red&quot;

            def blueFish():
                &quot;Sets the current fish color to blue&quot;

            def getFishColor():
                &quot;This returns the current fish color&quot; 

    This code, when evaluated, will create two interfaces called
    `CountFishInterface&#x27; and `ColorFishInterface&#x27;. These interfaces
    are defined by the `interface&#x27; statement.

    The prose documentation for the interfaces and their methods come
    from doc strings.  The method signature information comes from the
    signatures of the `def&#x27; statements.  Notice how there is no body
    for the def statements.  The interface does not implement a
    service to anything; it merely describes one.  Documentation
    strings on interfaces and interface methods are mandatory, a
    &#x27;pass&#x27; statement cannot be provided.  The interface equivalent of
    a pass statement is an empty doc string.

    You can also create interfaces that &quot;extend&quot; other interfaces.
    Here, you can see a new type of Interface that extends the
    CountFishInterface and ColorFishInterface:

        interface FishMarketInterface(CountFishInterface, ColorFishInterface):
            &quot;This is the documentation for the FishMarketInterface&quot;

            def getFishMonger():
                &quot;Returns the fish monger you can interact with&quot;

            def hireNewFishMonger(name):
                &quot;Hire a new fish monger&quot;

            def buySomeFish(quantity=1):
                &quot;Buy some fish at the market&quot;

    The FishMarketInteface extends upon the CountFishInterface and
    ColorfishInterface.


</pre>
<h3>Interface Assertion</h3>
<pre>
    The next step is to put classes and interfaces together by
    creating a concrete Python class that asserts that it implements
    an interface.  Here is an example FishMarket component that might
    do this:

        class FishError(Error):
            pass

        class FishMarket implements FishMarketInterface:
            number = 0
            color = None
            monger_name = &#x27;Crusty Barnacles&#x27; 

            def __init__(self, number, color):
                self.number = number
                self.color = color

            def oneFish(self):
                self.number += 1

            def twoFish(self):
                self.number += 2

            def redFish(self):
                self.color = &#x27;red&#x27;

            def blueFish(self):
                self.color = &#x27;blue&#x27;

            def getFishCount(self):
                return self.number

            def getFishColor(self):
                return self.color

            def getFishMonger(self):
                return self.monger_name

            def hireNewFishMonger(self, name):
                self.monger_name = name

            def buySomeFish(self, quantity=1):
                if quantity &gt; self.count:
                    raise FishError(&quot;There&#x27;s not enough fish&quot;)
                self.count -= quantity
                return quantity

    This new class, FishMarket defines a concrete class which
    implements the FishMarketInterface.  The object following the
    `implements&#x27; statement is called an &quot;interface assertion&quot;.  An
    interface assertion can be either an interface object, or tuple of
    interface assertions.

    The interface assertion provided in a `class&#x27; statement like this
    is stored in the class&#x27;s `__implements__&#x27; class attribute.  After
    interpreting the above example, you would have a class statement
    that can be examined like this with an &#x27;implements&#x27; built-in
    function:

        &gt;&gt;&gt; FishMarket
        &lt;class FishMarket at 8140f50&gt;
        &gt;&gt;&gt; FishMarket.__implements__
        (&lt;Interface FishMarketInterface at 81006f0&gt;,)
        &gt;&gt;&gt; f = FishMarket(6, &#x27;red&#x27;)
        &gt;&gt;&gt; implements(f, FishMarketInterface)
        1
        &gt;&gt;&gt;

    A class can realize more than one interface.  For example, say you
    had an interface called `ItemInterface&#x27; that described how an
    object worked as an item in a container object.  If you wanted to
    assert that FishMarket instances realized the ItemInterface
    interface as well as the FishMarketInterface, you can provide an
    interface assertion that contained a tuple of interface objects to
    the FishMarket class:

        class FishMarket implements FishMarketInterface, ItemInterface:
            # ...

    Interface assertions can also be used if you want to assert that
    one class implements an interface, and all of the interfaces that
    another class implements:

        class MyFishMarket implements FishMarketInterface, ItemInterface:
            # ...

        class YourFishMarket implements FooInterface, MyFishMarket.__implements__:
            # ...

    This new class YourFishMarket, asserts that it implements the
    FooInterface, as well as the interfaces implemented by the
    MyFishMarket class.

    It&#x27;s worth going into a little bit more detail about interface
    assertions.  An interface assertion is either an interface object,
    or a tuple of interface assertions.  For example:

        FooInterface

        FooInterface, (BarInteface, BobInterface)

        FooInterface, (BarInterface, (BobInterface, MyClass.__implements__))

    Are all valid interface assertions.  When two interfaces define
    the same attributes, the order in which information is preferred
    in the assertion is from top-to-bottom, left-to-right.

    There are other interface proposals that, in the need for
    simplicity, have combined the notion of class and interface to
    provide simple interface enforcement.  Interface objects have a
    `deferred&#x27; method that returns a deferred class that implements
    this behavior:

        &gt;&gt;&gt; FM = FishMarketInterface.deferred()
        &gt;&gt;&gt; class MyFM(FM): pass

        &gt;&gt;&gt; f = MyFM()
        &gt;&gt;&gt; f.getFishMonger()
        Traceback (innermost last):
          File &quot;&lt;stdin&gt;&quot;, line 1, in ?
        Interface.Exceptions.BrokenImplementation: 
        An object has failed to implement interface FishMarketInterface

                The getFishMonger attribute was not provided.
        &gt;&gt;&gt; 

    This provides for a bit of passive interface enforcement by
    telling you what you forgot to do to implement that interface.


</pre>
<h3>Formal Interface Syntax</h3>
<pre>
    Python syntax is defined in a modified BNF grammer notation
    described in the Python Reference Manual [8].  This section
    describes the proposed interface syntax using this grammar:

        interfacedef:   &quot;interface&quot; interfacename [extends] &quot;:&quot; suite
        extends:        &quot;(&quot; [expression_list] &quot;)&quot;
        interfacename:  identifier

    An interface definition is an executable statement.  It first
    evaluates the extends list, if present.  Each item in the extends
    list should evaluate to an interface object.

    The interface&#x27;s suite is then executed in a new execution frame
    (see the Python Reference Manual, section 4.1), using a newly
    created local namespace and the original global namespace.  When
    the interface&#x27;s suite finishes execution, its execution frame is
    discarded but its local namespace is saved as interface elements.
    An interface object is then created using the extends list for the
    base interfaces and the saved interface elements.  The interface
    name is bound to this interface object in the original local
    namespace.

    This PEP also proposes an extension to Python&#x27;s &#x27;class&#x27; statement:

        classdef:    &quot;class&quot; classname [inheritance] [implements] &quot;:&quot; suite
        implements:  &quot;implements&quot; implist
        implist:     expression-list

        classname,
        inheritance,
        suite,
        expression-list:  see the Python Reference Manual

    Before a class&#x27; suite is executed, the &#x27;inheritance&#x27; and
    &#x27;implements&#x27; statements are evaluated, if present.  The
    &#x27;inheritance&#x27; behavior is unchanged as defined in Section 7.6 of
    the Language Reference.

    The &#x27;implements&#x27;, if present, is evaluated after inheritance.
    This must evaluate to an interface specification, which is either
    an interface, or a tuple of interface specifications.  If a valid
    interface specification is present, the assertion is assigned to
    the class object&#x27;s &#x27;__implements__&#x27; attribute, as a tuple.

    This PEP does not propose any changes to the syntax of function
    definitions or assignments.


</pre>
<h3>Classes and Interfaces</h3>
<pre>
    The example interfaces above do not describe any kind of behavior
    for their methods, they just describe an interface that a typical
    FishMarket object would realize.

    You may notice a similarity between interfaces extending from
    other interfaces and classes sub-classing from other classes.
    This is a similar concept.  However it is important to note that
    interfaces extend interfaces and classes subclass classes.  You
    cannot extend a class or subclass an interface.  Classes and
    interfaces are separate.

    The purpose of a class is to share the implementation of how an
    object works.  The purpose of an interface is to document how to
    work with an object, not how the object is implemented.  It is
    possible to have several different classes with very different
    implementations realize the same interface.

    It&#x27;s also possible to implement one interface with many classes
    that mix in pieces the functionality of the interface or,
    conversely, it&#x27;s possible to have one class implement many
    interfaces.  Because of this, interfaces and classes should not be
    confused or intermingled.


</pre>
<h3>Interface-aware built-ins</h3>
<pre>
    A useful extension to Python&#x27;s list of built-in functions in the
    light of interface objects would be `implements()&#x27;.  This builtin
    would expect two arguments, an object and an interface, and return
    a true value if the object implements the interface, false
    otherwise.  For example:

        &gt;&gt;&gt; interface FooInterface: pass
        &gt;&gt;&gt; class Foo implements FooInterface: pass
        &gt;&gt;&gt; f = Foo()
        &gt;&gt;&gt; implements(f, FooInterface)
        1

    Currently, this functionality exists in the reference
    implementation as functions in the `Interface&#x27; package, requiring
    an &quot;import Interface&quot; to use it.  Its existence as a built-in
    would be purely for a convenience, and not necessary for using
    interfaces, and analogous to `isinstance()&#x27; for classes.


</pre>
<h3>Backward Compatibility</h3>
<pre>
    The proposed interface model does not introduce any backward
    compatibility issues in Python.  The proposed syntax, however,
    does.

    Any existing code that uses `interface&#x27; as an identifier will
    break.  There may be other kinds of backwards incompatibility that
    defining `interface&#x27; as a new keyword will introduce.  This
    extension to Python&#x27;s syntax does not change any existing syntax
    in any backward incompatible way.

    The new `from __future__&#x27; Python syntax[6], and the new warning
    framework [7] is ideal for resolving this backward
    incompatibility.  To use interface syntax now, a developer could
    use the statement:

        from __future__ import interfaces

    In addition, any code that uses the keyword `interface&#x27; as an
    identifier will be issued a warning from Python.  After the
    appropriate period of time, the interface syntax would become
    standard, the above import statement would do nothing, and any
    identifiers named `interface&#x27; would raise an exception.  This
    period of time is proposed to be 24 months.


</pre>
<h3>Summary of Proposed Changes to Python</h3>
<pre>
    Adding new `interface&#x27; keyword and extending class syntax with
    `implements&#x27;.

    Extending class interface to include __implements__.

    Add &#x27;implements(obj, interface)&#x27; built-in.


</pre>
<h3>Risks</h3>
<pre>
    This PEP proposes adding one new keyword to the Python language,
    `interface&#x27;.  This will break code.


</pre>
<h3>Open Issues</h3>
<pre>
    Goals

    Syntax

    Architecture


</pre>
<h3>Dissenting Opinion</h3>
<pre>
    This PEP has not yet been discussed on python-dev.
        

</pre>
<h3>References</h3>
<pre>
    [1] <a href="http://mail.python.org/pipermail/types-sig/1998-December/date.html">http://mail.python.org/pipermail/types-sig/1998-December/date.html</a>

    [2] <a href="http://www.zope.org">http://www.zope.org</a>

    [3] <a href="pep-0232.html">PEP 232</a>, Function Attributes, Warsaw
        <a href="http://www.python.org/dev/peps/pep-0232/">http://www.python.org/dev/peps/pep-0232/</a>

    [4] <a href="pep-0233.html">PEP 233</a>, Python Online Help, Prescod
        <a href="http://www.python.org/dev/peps/pep-0233/">http://www.python.org/dev/peps/pep-0233/</a>

    [5] <a href="http://www.lemburg.com/files/python/mxProxy.html">http://www.lemburg.com/files/python/mxProxy.html</a>

    [6] <a href="pep-0236.html">PEP 236</a>, Back to the __future__, Peters
        <a href="http://www.python.org/dev/peps/pep-0236/">http://www.python.org/dev/peps/pep-0236/</a>

    [7] <a href="pep-0230.html">PEP 230</a>, Warning Framework, van Rossum
        <a href="http://www.python.org/dev/peps/pep-0236/">http://www.python.org/dev/peps/pep-0236/</a>


</pre>
<h3>Copyright</h3>
<pre>
    This document has been placed in the public domain.



</pre>
</div>
</body>
</html>
