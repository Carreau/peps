<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN"
                      "http://www.w3.org/TR/REC-html40/loose.dtd">
<html>
<!--
This HTML is auto-generated.  DO NOT EDIT THIS FILE!  If you are writing a new
PEP, see http://www.python.org/peps/pep-0001.html for instructions and links
to templates.  DO NOT USE THIS HTML FILE AS YOUR TEMPLATE!
-->
<head>
  <title>PEP 363 -- Syntax For Dynamic Attribute Access</title>
  <link rel="STYLESHEET" href="style.css" type="text/css" />
</head>
<body bgcolor="white">
<table class="navigation" cellpadding="0" cellspacing="0"
       width="100%" border="0">
<tr><td class="navicon" width="150" height="35">
<a href="../" title="Python Home Page">
<img src="../pics/PyBanner030.gif" alt="[Python]"
 border="0" width="150" height="35" /></a></td>
<td class="textlinks" align="left">
[<b><a href="../">Python Home</a></b>]
[<b><a href=".">PEP Index</a></b>]
[<b><a href="pep-0363.txt">PEP Source</a></b>]
</td></tr></table>
<div class="header">
<table border="0">
  <tr><th>PEP:&nbsp;</th><td>363</td></tr>
  <tr><th>Title:&nbsp;</th><td>Syntax For Dynamic Attribute Access</td></tr>
  <tr><th>Version:&nbsp;</th><td>$Revision$</td></tr>
  <tr><th>Last-Modified:&nbsp;</th><td><a href="https://hg.python.org/peps/file/tip/pep-0363.txt">$Date$</a> </td></tr>
  <tr><th>Author:&nbsp;</th><td>Ben North &lt;ben&#32;&#97;t&#32;redfrontdoor.org&gt;</td></tr>
  <tr><th>Status:&nbsp;</th><td>Rejected</td></tr>
  <tr><th>Type:&nbsp;</th><td>Standards Track</td></tr>
  <tr><th>Content-Type:&nbsp;</th><td><a href="pep-0009.html">text/plain</a> </td></tr>
  <tr><th>Created:&nbsp;</th><td>29-Jan-2007</td></tr>
  <tr><th>Post-History:&nbsp;</th><td>12-Feb-2007</td></tr>
</table>
</div>
<hr />
<div class="content">
<h3>Abstract</h3>
<pre>
    Dynamic attribute access is currently possible using the &quot;getattr&quot;
    and &quot;setattr&quot; builtins.  The present PEP suggests a new syntax to
    make such access easier, allowing the coder for example to write

        x.(&#x27;foo_%d&#x27; % n) += 1

        z = y.(&#x27;foo_%d&#x27; % n).(&#x27;bar_%s&#x27; % s)

    instead of

        attr_name = &#x27;foo_%d&#x27; % n
        setattr(x, attr_name, getattr(x, attr_name) + 1)

        z = getattr(getattr(y, &#x27;foo_%d&#x27; % n), &#x27;bar_%s&#x27; % s)


</pre>
<h3>Rationale</h3>
<pre>
    Dictionary access and indexing both have a friendly invocation
    syntax: instead of x.__getitem__(12) the coder can write x[12].
    This also allows the use of subscripted elements in an augmented
    assignment, as in &quot;x[12] += 1&quot;.  The present proposal brings this
    ease-of-use to dynamic attribute access too.

    Attribute access is currently possible in two ways:

    * When the attribute name is known at code-writing time, the
      &quot;.NAME&quot; trailer can be used, as in

          x.foo = 42
          y.bar += 100

    * When the attribute name is computed dynamically at run-time, the
      &quot;getattr&quot; and &quot;setattr&quot; builtins must be used:

          x = getattr(y, &#x27;foo_%d&#x27; % n)
          setattr(z, &#x27;bar_%s&#x27; % s, 99)

      The &quot;getattr&quot; builtin also allows the coder to specify a default
      value to be returned in the event that the object does not have
      an attribute of the given name:

          x = getattr(y, &#x27;foo_%d&#x27; % n, 0)

    This PEP describes a new syntax for dynamic attribute access ---
    &quot;x.(expr)&quot; --- with examples given in the Abstract above.

    (The new syntax could also allow the provision of a default value in
    the &quot;get&quot; case, as in:

        x = y.(&#x27;foo_%d&#x27; % n, None)

    This 2-argument form of dynamic attribute access would not be
    permitted as the target of an (augmented or normal) assignment.  The
    &quot;Discussion&quot; section below includes opinions specifically on the
    2-argument extension.)

    Finally, the new syntax can be used with the &quot;del&quot; statement, as in

        del x.(attr_name)


</pre>
<h3>Impact On Existing Code</h3>
<pre>
    The proposed new syntax is not currently valid, so no existing
    well-formed programs have their meaning altered by this proposal.

    Across all &quot;*.py&quot; files in the 2.5 distribution, there are around
    600 uses of &quot;getattr&quot;, &quot;setattr&quot; or &quot;delattr&quot;.  They break down as
    follows (figures have some room for error because they were
    arrived at by partially-manual inspection):

        c.300 uses of plain &quot;getattr(x, attr_name)&quot;, which could be
              replaced with the new syntax;

        c.150 uses of the 3-argument form, i.e., with the default
              value; these could be replaced with the 2-argument form
              of the new syntax (the cases break down into c.125 cases
              where the attribute name is a literal string, and c.25
              where it&#x27;s only known at run-time);

        c.5   uses of the 2-argument form with a literal string
              attribute name, which I think could be replaced with the
              standard &quot;x.attribute&quot; syntax;

        c.120 uses of setattr, of which 15 use getattr to find the
              new value; all could be replaced with the new syntax,
              the 15 where getattr is also involved would show a
              particular increase in clarity;

        c.5   uses which would have to stay as &quot;getattr&quot; because they
              are calls of a variable named &quot;getattr&quot; whose default
              value is the builtin &quot;getattr&quot;;

        c.5   uses of the 2-argument form, inside a try/except block
              which catches AttributeError and uses a default value
              instead; these could use 2-argument form of the new
              syntax;

        c.10  uses of &quot;delattr&quot;, which could use the new syntax.

    As examples, the line

        setattr(self, attr, change_root(self.root, getattr(self, attr)))

    from Lib/distutils/command/install.py could be rewritten

        self.(attr) = change_root(self.root, self.(attr))

    and the line

        setattr(self, method_name, getattr(self.metadata, method_name))

    from Lib/distutils/dist.py could be rewritten

        self.(method_name) = self.metadata.(method_name)


</pre>
<h3>Performance Impact</h3>
<pre>
    Initial pystone measurements are inconclusive, but suggest there may
    be a performance penalty of around 1% in the pystones score with the
    patched version.  One suggestion is that this is because the longer
    main loop in ceval.c hurts the cache behaviour, but this has not
    been confirmed.

    On the other hand, measurements suggest a speed-up of around 40--45%
    for dynamic attribute access.


</pre>
<h3>Error Cases</h3>
<pre>
    Only strings are permitted as attribute names, so for instance the
    following error is produced:

     &gt;&gt;&gt; x.(99) = 8
        Traceback (most recent call last):
          File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;
        TypeError: attribute name must be string, not &#x27;int&#x27;

    This is handled by the existing PyObject_GetAttr function.


</pre>
<h3>Draft Implementation</h3>
<pre>
    A draft implementation adds a new alternative to the &quot;trailer&quot;
    clause in Grammar/Grammar; a new AST type, &quot;DynamicAttribute&quot; in
    Python.asdl, with accompanying changes to symtable.c, ast.c, and
    compile.c, and three new opcodes (load/store/del) with
    accompanying changes to opcode.h and ceval.c.  The patch consists
    of c.180 additional lines in the core code, and c.100 additional
    lines of tests.  It is available as sourceforge patch #1657573 [1].


</pre>
<h3>Mailing Lists Discussion</h3>
<pre>
    Initial posting of this PEP in draft form was to python-ideas on
    20070209 [2], and the response was generally positive.  The PEP was
    then posted to python-dev on 20070212 [3], and an interesting
    discussion ensued.  A brief summary:

    Initially, there was reasonable (but not unanimous) support for the
    idea, although the precise choice of syntax had a more mixed
    reception.  Several people thought the &quot;.&quot; would be too easily
    overlooked, with the result that the syntax could be confused with a
    method/function call.  A few alternative syntaxes were suggested:

        obj.(foo)
        obj.[foo]
        obj.{foo}
        obj{foo}
        obj.*foo
        obj-&gt;foo
        obj&lt;-foo
        obj@[foo]
        obj.[[foo]]

    with &quot;obj.[foo]&quot; emerging as the preferred one.  In this initial
    discussion, the two-argument form was universally disliked, so it
    was to be taken out of the PEP.

    Discussion then took a step back to whether this particular feature
    provided enough benefit to justify new syntax.  As well as requiring
    coders to become familiar with the new syntax, there would also be
    the problem of backward compatibility --- code using the new syntax
    would not run on older pythons.

    Instead of new syntax, a new &quot;wrapper class&quot; was proposed, with the
    following specification / conceptual implementation suggested by
    Martin von Loewis:

        class attrs:
           def __init__(self, obj):
             self.obj = obj
           def __getitem__(self, name):
             return getattr(self.obj, name)
           def __setitem__(self, name, value):
             return setattr(self.obj, name, value)
           def __delitem__(self, name):
             return delattr(self, name)
           def __contains__(self, name):
             return hasattr(self, name)

    This was considered a cleaner and more elegant solution to the
    original problem.  (Another suggestion was a mixin class providing
    dictionary-style access to an object&#x27;s attributes.)

    The decision was made that the present PEP did not meet the burden
    of proof for the introduction of new syntax, a view which had been
    put forward by some from the beginning of the discussion.  The
    wrapper class idea was left open as a possibility for a future PEP.


</pre>
<h3>References</h3>
<pre>
    [1] Sourceforge patch #1657573
        <a href="http://sourceforge.net/tracker/index.php?func=detail&amp;aid=1657573&amp;group_id=5470&amp;atid=305470">http://sourceforge.net/tracker/index.php?func=detail&amp;aid=1657573&amp;group_id=5470&amp;atid=305470</a>

    [2] <a href="http://mail.python.org/pipermail/python-ideas/2007-February/000210.html">http://mail.python.org/pipermail/python-ideas/2007-February/000210.html</a>
        and following posts

    [3] <a href="http://mail.python.org/pipermail/python-dev/2007-February/070939.html">http://mail.python.org/pipermail/python-dev/2007-February/070939.html</a>
        and following posts


</pre>
<h3>Copyright</h3>
<pre>
    This document has been placed in the public domain.


</pre>
</div>
</body>
</html>
