<!--
This HTML is auto-generated.  DO NOT EDIT THIS FILE!  If you are writing a new
PEP, see http://www.python.org/dev/peps/pep-0001 for instructions and links
to templates.  DO NOT USE THIS HTML FILE AS YOUR TEMPLATE!
-->
<table class="rfc2822 docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">PEP:</th><td class="field-body">520</td>
</tr>
<tr class="field"><th class="field-name">Title:</th><td class="field-body">Preserving Class Attribute Definition Order</td>
</tr>
<tr class="field"><th class="field-name">Version:</th><td class="field-body">$Revision$</td>
</tr>
<tr class="field"><th class="field-name">Last-Modified:</th><td class="field-body"><a class="reference external" href="https://hg.python.org/peps/file/tip/pep-0520.txt">$Date$</a></td>
</tr>
<tr class="field"><th class="field-name">Author:</th><td class="field-body">Eric Snow &lt;ericsnowcurrently&#32;&#97;t&#32;gmail.com&gt;</td>
</tr>
<tr class="field"><th class="field-name">Status:</th><td class="field-body">Draft</td>
</tr>
<tr class="field"><th class="field-name">Type:</th><td class="field-body">Standards Track</td>
</tr>
<tr class="field"><th class="field-name">Content-Type:</th><td class="field-body"><a class="reference external" href="/dev/peps/pep-0012">text/x-rst</a></td>
</tr>
<tr class="field"><th class="field-name">Created:</th><td class="field-body">7-Jun-2016</td>
</tr>
<tr class="field"><th class="field-name">Python-Version:</th><td class="field-body">3.6</td>
</tr>
<tr class="field"><th class="field-name">Post-History:</th><td class="field-body">7-Jun-2016, 11-Jun-2016, 20-Jun-2016</td>
</tr>
</tbody>
</table>
<hr />
<div class="contents topic" id="contents">
<p class="topic-title first">Contents</p>
<ul class="simple">
<li><a class="reference internal" href="#abstract" id="id1">Abstract</a></li>
<li><a class="reference internal" href="#motivation" id="id2">Motivation</a></li>
<li><a class="reference internal" href="#specification" id="id3">Specification</a><ul>
<li><a class="reference internal" href="#why-a-tuple" id="id4">Why a tuple?</a></li>
<li><a class="reference internal" href="#why-a-read-only-attribute" id="id5">Why a read-only attribute?</a></li>
<li><a class="reference internal" href="#why-ignore-dunder-names" id="id6">Why ignore &quot;dunder&quot; names?</a></li>
<li><a class="reference internal" href="#why-none-instead-of-an-empty-tuple" id="id7">Why None instead of an empty tuple?</a></li>
<li><a class="reference internal" href="#why-none-instead-of-not-setting-the-attribute" id="id8">Why None instead of not setting the attribute?</a></li>
<li><a class="reference internal" href="#why-constrain-manually-set-values" id="id9">Why constrain manually set values?</a></li>
<li><a class="reference internal" href="#why-is-definition-order-even-necessary" id="id10">Why is __definition_order__ even necessary?</a></li>
</ul>
</li>
<li><a class="reference internal" href="#support-for-c-api-types" id="id11">Support for C-API Types</a></li>
<li><a class="reference internal" href="#compatibility" id="id12">Compatibility</a></li>
<li><a class="reference internal" href="#changes" id="id13">Changes</a></li>
<li><a class="reference internal" href="#other-python-implementations" id="id14">Other Python Implementations</a></li>
<li><a class="reference internal" href="#implementation" id="id15">Implementation</a></li>
<li><a class="reference internal" href="#alternatives" id="id16">Alternatives</a><ul>
<li><a class="reference internal" href="#cls-dict-as-ordereddict" id="id17">cls.__dict__ as OrderedDict</a></li>
<li><a class="reference internal" href="#a-namespace-keyword-arg-for-class-definition" id="id18">A &quot;namespace&quot; Keyword Arg for Class Definition</a></li>
<li><a class="reference internal" href="#a-stdlib-metaclass-that-implements-prepare-with-ordereddict" id="id19">A stdlib Metaclass that Implements __prepare__() with OrderedDict</a></li>
<li><a class="reference internal" href="#set-definition-order-at-compile-time" id="id20">Set __definition_order__ at Compile-time</a></li>
</ul>
</li>
<li><a class="reference internal" href="#references" id="id21">References</a></li>
<li><a class="reference internal" href="#copyright" id="id22">Copyright</a></li>
</ul>
</div>
<div class="section" id="abstract">
<h1><a class="toc-backref" href="#id1">Abstract</a></h1>
<p>When a class is defined using a <tt class="docutils literal">class</tt> statement, the class body is
executed within a namespace.  After the execution completes, that
namespace is copied into new <tt class="docutils literal">dict</tt> and the original definition
namespace is discarded.  The new copy is stored away as the class's
namespace and is exposed as <tt class="docutils literal">__dict__</tt> through a read-only proxy.</p>
<p>This PEP preserves the order in which the attributes in the definition
namespace were added to it, before that namespace is discarded.  This
means it reflects the definition order of the class body.  That order
will now be preserved in the <tt class="docutils literal">__definition_order__</tt> attribute of the
class.  This allows introspection of the original definition order,
e.g. by class decorators.</p>
<p>Additionally, this PEP changes the default class definition namespace
to <tt class="docutils literal">OrderedDict</tt>.  The long-lived class namespace (<tt class="docutils literal">__dict__</tt>) will
remain a <tt class="docutils literal">dict</tt>.</p>
</div>
<div class="section" id="motivation">
<h1><a class="toc-backref" href="#id2">Motivation</a></h1>
<p>Currently Python does not preserve the order in which attributes are
added to the class definition namespace. The namespace used during
execution of a class body defaults to <tt class="docutils literal">dict</tt>.  If the metaclass
defines <tt class="docutils literal">__prepare__()</tt> then the result of calling it is used.  Thus,
before this PEP, to access your class definition namespace you must
use <tt class="docutils literal">OrderedDict</tt> along with a metaclass. Then you must preserve the
definition order (from the <tt class="docutils literal">OrderedDict</tt>) yourself.  This has a
couple of problems.</p>
<p>First, it requires the use of a metaclass.  Metaclasses introduce an
extra level of complexity to code and in some cases (e.g. conflicts)
are a problem.  So reducing the need for them is worth doing when the
opportunity presents itself.  <a class="reference external" href="/dev/peps/pep-0422">PEP 422</a> and <a class="reference external" href="/dev/peps/pep-0487">PEP 487</a> discuss this at
length.  Given that we now have a C implementation of <tt class="docutils literal">OrderedDict</tt>
and that <tt class="docutils literal">OrderedDict</tt> is the common use case for <tt class="docutils literal">__prepare__()</tt>,
we have such an opportunity by defaulting to <tt class="docutils literal">OrderedDict</tt>.</p>
<p>Second, only classes that opt in to using the <tt class="docutils literal">OrderedDict</tt>-based
metaclass will have access to the definition order. This is problematic
for cases where universal access to the definition order is important.
One of the original motivating use cases for this PEP is generic class
decorators that make use of the definition order.</p>
</div>
<div class="section" id="specification">
<h1><a class="toc-backref" href="#id3">Specification</a></h1>
<p>Part 1:</p>
<ul class="simple">
<li>the order in which class attributes are defined is preserved in the
new <tt class="docutils literal">__definition_order__</tt> attribute on each class</li>
<li>&quot;dunder&quot; attributes (e.g. <tt class="docutils literal">__init__</tt>, <tt class="docutils literal">__module__</tt>) are ignored</li>
<li><tt class="docutils literal">__definition_order__</tt> is a <tt class="docutils literal">tuple</tt> (or <tt class="docutils literal">None</tt>)</li>
<li><tt class="docutils literal">__definition_order__</tt> is a read-only attribute</li>
<li><tt class="docutils literal">__definition_order__</tt> is always set:<ol class="arabic">
<li>if <tt class="docutils literal">__definition_order__</tt> is defined in the class body then it
must be a <tt class="docutils literal">tuple</tt> of identifiers or <tt class="docutils literal">None</tt>; any other value
will result in <tt class="docutils literal">TypeError</tt></li>
<li>classes that do not have a class definition (e.g. builtins) have
their <tt class="docutils literal">__definition_order__</tt> set to <tt class="docutils literal">None</tt></li>
<li>classes for which <cite>__prepare__()`</cite> returned something other than
<tt class="docutils literal">OrderedDict</tt> (or a subclass) have their <tt class="docutils literal">__definition_order__</tt>
set to <tt class="docutils literal">None</tt> (except where #1 applies)</li>
</ol>
</li>
</ul>
<p>Part 2:</p>
<ul class="simple">
<li>the default class <em>definition</em> namespace is now <tt class="docutils literal">OrderdDict</tt></li>
</ul>
<p>The following code demonstrates roughly equivalent semantics for the
default behavior:</p>
<pre class="literal-block">
class Meta(type):
    &#64;classmethod
    def __prepare__(cls, *args, **kwargs):
        return OrderedDict()

class Spam(metaclass=Meta):
    ham = None
    eggs = 5
    __definition_order__ = tuple(k for k in locals()
                                 if not (k.startswith('__') and
                                         k.endswith('__')))
</pre>
<p>Note that [<a class="reference internal" href="#pep487">pep487</a>] proposes a similar solution, albeit as part of a
broader proposal.</p>
<div class="section" id="why-a-tuple">
<h2><a class="toc-backref" href="#id4">Why a tuple?</a></h2>
<p>Use of a tuple reflects the fact that we are exposing the order in
which attributes on the class were <em>defined</em>.  Since the definition
is already complete by the time <tt class="docutils literal">__definition_order__</tt> is set, the
content and order of the value won't be changing.  Thus we use a type
that communicates that state of immutability.</p>
</div>
<div class="section" id="why-a-read-only-attribute">
<h2><a class="toc-backref" href="#id5">Why a read-only attribute?</a></h2>
<p>As with the use of tuple, making <tt class="docutils literal">__definition_order__</tt> a read-only
attribute communicates the fact that the information it represents is
complete.  Since it represents the state of a particular one-time event
(execution of the class definition body), allowing the value to be
replaced would reduce confidence that the attribute corresponds to the
original class body.</p>
<p>If a use case for a writable (or mutable) <tt class="docutils literal">__definition_order__</tt>
arises, the restriction may be loosened later.  Presently this seems
unlikely and furthermore it is usually best to go immutable-by-default.</p>
<p>Note that <tt class="docutils literal">__definition_order__</tt> is centered on the class definition
body.  The use cases for dealing with the class namespace (<tt class="docutils literal">__dict__</tt>)
post-definition are a separate matter.  <tt class="docutils literal">__definition_order__</tt> would
be a significantly misleading name for a feature focused on more than
class definition.</p>
<p>See [<a class="reference internal" href="#nick-concern">nick_concern</a>] for more discussion.</p>
</div>
<div class="section" id="why-ignore-dunder-names">
<h2><a class="toc-backref" href="#id6">Why ignore &quot;dunder&quot; names?</a></h2>
<p>Names starting and ending with &quot;__&quot; are reserved for use by the
interpreter.  In practice they should not be relevant to the users of
<tt class="docutils literal">__definition_order__</tt>.  Instead, for nearly everyone they would only
be clutter, causing the same extra work for everyone.</p>
</div>
<div class="section" id="why-none-instead-of-an-empty-tuple">
<h2><a class="toc-backref" href="#id7">Why None instead of an empty tuple?</a></h2>
<p>A key objective of adding <tt class="docutils literal">__definition_order__</tt> is to preserve
information in class definitions which was lost prior to this PEP.
One consequence is that <tt class="docutils literal">__definition_order__</tt> implies an original
class definition.  Using <tt class="docutils literal">None</tt> allows us to clearly distinquish
classes that do not have a definition order.  An empty tuple clearly
indicates a class that came from a definition statement but did not
define any attributes there.</p>
</div>
<div class="section" id="why-none-instead-of-not-setting-the-attribute">
<h2><a class="toc-backref" href="#id8">Why None instead of not setting the attribute?</a></h2>
<p>The absence of an attribute requires more complex handling than <tt class="docutils literal">None</tt>
does for consumers of <tt class="docutils literal">__definition_order__</tt>.</p>
</div>
<div class="section" id="why-constrain-manually-set-values">
<h2><a class="toc-backref" href="#id9">Why constrain manually set values?</a></h2>
<p>If <tt class="docutils literal">__definition_order__</tt> is manually set in the class body then it
will be used.  We require it to be a tuple of identifiers (or <tt class="docutils literal">None</tt>)
so that consumers of <tt class="docutils literal">__definition_order__</tt> may have a consistent
expectation for the value.  That helps maximize the feature's
usefulness.</p>
<p>We could also also allow an arbitrary iterable for a manually set
<tt class="docutils literal">__definition_order__</tt> and convert it into a tuple.  However, not
all iterables infer a definition order (e.g. <tt class="docutils literal">set</tt>).  So we opt in
favor of requiring a tuple.</p>
</div>
<div class="section" id="why-is-definition-order-even-necessary">
<h2><a class="toc-backref" href="#id10">Why is __definition_order__ even necessary?</a></h2>
<p>Since the definition order is not preserved in <tt class="docutils literal">__dict__</tt>, it is
lost once class definition execution completes.  Classes <em>could</em>
explicitly set the attribute as the last thing in the body.  However,
then independent decorators could only make use of classes that had done
so.  Instead, <tt class="docutils literal">__definition_order__</tt> preserves this one bit of info
from the class body so that it is universally available.</p>
</div>
</div>
<div class="section" id="support-for-c-api-types">
<h1><a class="toc-backref" href="#id11">Support for C-API Types</a></h1>
<p>Arguably, most C-defined Python types (e.g. built-in, extension modules)
have a roughly equivalent concept of a definition order. So conceivably
<tt class="docutils literal">__definition_order__</tt> could be set for such types automatically. This
PEP does not introduce any such support. However, it does not prohibit
it either.</p>
</div>
<div class="section" id="compatibility">
<h1><a class="toc-backref" href="#id12">Compatibility</a></h1>
<p>This PEP does not break backward compatibility, except in the case that
someone relies <em>strictly</em> on <tt class="docutils literal">dict</tt> as the class definition namespace.
This shouldn't be a problem since <tt class="docutils literal">issubclass(OrderedDict, dict)</tt> is
true.</p>
</div>
<div class="section" id="changes">
<h1><a class="toc-backref" href="#id13">Changes</a></h1>
<p>In addition to the class syntax, the following expose the new behavior:</p>
<ul class="simple">
<li>builtins.__build_class__</li>
<li>types.prepare_class</li>
<li>types.new_class</li>
</ul>
</div>
<div class="section" id="other-python-implementations">
<h1><a class="toc-backref" href="#id14">Other Python Implementations</a></h1>
<p>Pending feedback, the impact on Python implementations is expected to
be minimal.  If a Python implementation cannot support switching to
<cite>OrderedDict`</cite>-by-default then it can always set <tt class="docutils literal">__definition_order__</tt>
to <tt class="docutils literal">None</tt>.</p>
</div>
<div class="section" id="implementation">
<h1><a class="toc-backref" href="#id15">Implementation</a></h1>
<p>The implementation is found in the tracker. [<a class="reference internal" href="#impl">impl</a>]</p>
</div>
<div class="section" id="alternatives">
<h1><a class="toc-backref" href="#id16">Alternatives</a></h1>
<div class="section" id="cls-dict-as-ordereddict">
<h2><a class="toc-backref" href="#id17">cls.__dict__ as OrderedDict</a></h2>
<p>Instead of storing the definition order in <tt class="docutils literal">__definition_order__</tt>,
the now-ordered definition namespace could be copied into a new
<tt class="docutils literal">OrderedDict</tt>.  This would then be used as the mapping proxied as
<tt class="docutils literal">__dict__</tt>.  Doing so would mostly provide the same semantics.</p>
<p>However, using <tt class="docutils literal">OrderedDict</tt> for <tt class="docutils literal">__dict__</tt> would obscure the
relationship with the definition namespace, making it less useful.
Additionally, doing this would require significant changes to the
semantics of the concrete <tt class="docutils literal">dict</tt> C-API.</p>
</div>
<div class="section" id="a-namespace-keyword-arg-for-class-definition">
<h2><a class="toc-backref" href="#id18">A &quot;namespace&quot; Keyword Arg for Class Definition</a></h2>
<p><a class="reference external" href="/dev/peps/pep-0422">PEP 422</a> introduced a new &quot;namespace&quot; keyword arg to class definitions
that effectively replaces the need to <tt class="docutils literal">__prepare__()</tt>. [<a class="reference internal" href="#pep422">pep422</a>]
However, the proposal was withdrawn in favor of the simpler <a class="reference external" href="/dev/peps/pep-0487">PEP 487</a>.</p>
</div>
<div class="section" id="a-stdlib-metaclass-that-implements-prepare-with-ordereddict">
<h2><a class="toc-backref" href="#id19">A stdlib Metaclass that Implements __prepare__() with OrderedDict</a></h2>
<p>This has all the same problems as writing your own metaclass.  The
only advantage is that you don't have to actually write this
metaclass.  So it doesn't offer any benefit in the context of this
PEP.</p>
</div>
<div class="section" id="set-definition-order-at-compile-time">
<h2><a class="toc-backref" href="#id20">Set __definition_order__ at Compile-time</a></h2>
<p>Each class's <tt class="docutils literal">__qualname__</tt> is determined at compile-time.
This same concept could be applied to <tt class="docutils literal">__definition_order__</tt>.
The result of composing <tt class="docutils literal">__definition_order__</tt> at compile-time
would be nearly the same as doing so at run-time.</p>
<p>Comparative implementation difficulty aside, the key difference
would be that at compile-time it would not be practical to
preserve definition order for attributes that are set dynamically
in the class body (e.g. <tt class="docutils literal"><span class="pre">locals()[name]</span> = value</tt>).  However,
they should still be reflected in the definition order.  One
posible resolution would be to require class authors to manually
set <tt class="docutils literal">__definition_order__</tt> if they define any class attributes
dynamically.</p>
<p>Ultimately, the use of <tt class="docutils literal">OrderedDict</tt> at run-time or compile-time
discovery is almost entirely an implementation detail.</p>
</div>
</div>
<div class="section" id="references">
<h1><a class="toc-backref" href="#id21">References</a></h1>
<table class="docutils citation" frame="void" id="impl" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[impl]</td><td>issue #24254
(<a class="reference external" href="https://bugs.python.org/issue24254">https://bugs.python.org/issue24254</a>)</td></tr>
</tbody>
</table>
<table class="docutils citation" frame="void" id="nick-concern" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[nick_concern]</td><td>Nick's concerns about mutability
(<a class="reference external" href="https://mail.python.org/pipermail/python-dev/2016-June/144883.html">https://mail.python.org/pipermail/python-dev/2016-June/144883.html</a>)</td></tr>
</tbody>
</table>
<table class="docutils citation" frame="void" id="pep422" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[pep422]</td><td><a class="reference external" href="/dev/peps/pep-0422">PEP 422</a>
(<a class="reference external" href="https://www.python.org/dev/peps/pep-0422/#order-preserving-classes">https://www.python.org/dev/peps/pep-0422/#order-preserving-classes</a>)</td></tr>
</tbody>
</table>
<table class="docutils citation" frame="void" id="pep487" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[pep487]</td><td><a class="reference external" href="/dev/peps/pep-0487">PEP 487</a>
(<a class="reference external" href="https://www.python.org/dev/peps/pep-0487/#defining-arbitrary-namespaces">https://www.python.org/dev/peps/pep-0487/#defining-arbitrary-namespaces</a>)</td></tr>
</tbody>
</table>
<table class="docutils citation" frame="void" id="orig" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[orig]</td><td>original discussion
(<a class="reference external" href="https://mail.python.org/pipermail/python-ideas/2013-February/019690.html">https://mail.python.org/pipermail/python-ideas/2013-February/019690.html</a>)</td></tr>
</tbody>
</table>
<table class="docutils citation" frame="void" id="followup1" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[followup1]</td><td>follow-up 1
(<a class="reference external" href="https://mail.python.org/pipermail/python-dev/2013-June/127103.html">https://mail.python.org/pipermail/python-dev/2013-June/127103.html</a>)</td></tr>
</tbody>
</table>
<table class="docutils citation" frame="void" id="followup2" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[followup2]</td><td>follow-up 2
(<a class="reference external" href="https://mail.python.org/pipermail/python-dev/2015-May/140137.html">https://mail.python.org/pipermail/python-dev/2015-May/140137.html</a>)</td></tr>
</tbody>
</table>
</div>
<div class="section" id="copyright">
<h1><a class="toc-backref" href="#id22">Copyright</a></h1>
<p>This document has been placed in the public domain.</p>
<!-- Local Variables:
mode: indented-text
indent-tabs-mode: nil
sentence-end-double-space: t
fill-column: 70
coding: utf-8
End: -->
</div>

